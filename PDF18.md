## 第十八章 直面配分函數 (開篇引言)

2018-01-12

Confronting the Partition Function

https://www.youtube.com/watch?v=yw1JDopTuwo

**重點摘要:**
許多機率模型（尤其是無向圖模型）由一個未歸一化的機率分佈 `p̃(x;θ)` 定義。為了獲得一個有效的機率分佈 `p(x;θ)`，必須將 `p̃(x;θ)` 除以一個歸一化常數，即配分函數 `Z(θ)` (公式 18.1)。配分函數是未歸一化機率在所有狀態上的積分（對於連續變量）或求和（對於離散變量）(公式 18.2, 18.3)。對於許多有趣的深度學習模型而言，這個積分或求和難以計算。雖然有些模型設計成具有易於處理的歸一化常數或避免直接計算 `p(x)`，但其他模型則必須直接面對這個挑戰。本章旨在介紹用於訓練和評估那些具有難以處理的配分函數的模型的技術。

**Q&A:**
**Q:** 什麼是配分函數 `Z(θ)`？為什麼在許多機率模型中它是一個重要的概念？
**A:** 配分函數 `Z(θ)` 是一個歸一化常數，定義為未歸一化機率分佈 `p̃(x;θ)` 在其所有可能狀態 `x` 上的積分（對於連續變量）或求和（對於離散變量）。它之所以重要，是因為有效的機率分佈 `p(x;θ)` 必須通過將 `p̃(x;θ)` 除以 `Z(θ)` 來獲得，即 `p(x;θ) = (1/Z(θ))p̃(x;θ)`，以確保機率分佈在所有狀態上的總和（或積分）為1。

**Q:** 為什麼配分函數對於許多深度學習模型來說是一個挑戰？
**A:** 因為對於許多有趣的深度學習模型，特別是那些具有複雜依賴結構或高維狀態空間的模型，計算配分函數所需的積分或求和操作在計算上是難以處理的 (intractable)，甚至是不可能的。

**Q:** 本章的主要目標是什麼？
**A:** 本章的主要目標是介紹一系列用於訓練和評估那些具有難以處理的配分函數的機率模型的技術。這些技術旨在繞過或近似計算配分函數及其相關的梯度。

---

## 18.1 對數概似梯度

**重點摘要:**
通過最大概似學習無向模型特別困難，因為配分函數 `Z(θ)` 依賴於模型參數 `θ`。對數概似 `log p(x;θ)` 相對於參數 `θ` 的梯度包含兩項：
`∇_θ log p(x;θ) = ∇_θ log p̃(x;θ) - ∇_θ log Z(θ)` (公式 18.4)
這兩項在機器學習中被稱為「正相 (positive phase)」和「負相 (negative phase)」。
對於大多數無向模型，負相 `∇_θ log Z(θ)` 是困難的。通過一系列推導，可以證明：
`∇_θ log Z(θ) = E_{x'~p(x';θ)}[∇_θ log p̃(x';θ)]` (公式 18.13, 18.15)
這意味著負相梯度是在模型自身定義的機率分佈 `p(x;θ)` 下，對未歸一化對數機率 `log p̃(x;θ)` 的梯度的期望。
因此，整個對數概似梯度可以寫成：
`∇_θ log p(x;θ) = ∇_θ log p̃(x;θ) - E_{x'~p(x';θ)}[∇_θ log p̃(x';θ)]`
正相項 `∇_θ log p̃(x;θ)` 通常易於計算（如果沒有潛變量或潛變量間相互作用少）。本章主要探討負相計算的難點。在深度學習文獻中，常用能量函數 `E(x;θ)` 來參數化 `log p̃(x;θ) = -E(x;θ)`。在這種情況下，正相可以解釋為降低訓練樣本的能量，負相可以解釋為提高模型生成樣本的能量。

**Q&A:**
**Q:** 對數概似梯度包含哪兩個主要部分？它們分別被稱為什麼？
**A:** 對數概似梯度 `∇_θ log p(x;θ)` 包含兩個主要部分：
1.  `∇_θ log p̃(x;θ)`: 稱為「正相 (positive phase)」。
2.  `- ∇_θ log Z(θ)`: 稱為「負相 (negative phase)」。

**Q:** 負相梯度 `∇_θ log Z(θ)` 可以如何表示？這個表示意味著什麼？
**A:** 負相梯度可以表示為 `∇_θ log Z(θ) = E_{x'~p(x';θ)}[∇_θ log p̃(x';θ)]` (公式 18.13, 18.15)。
這意味著負相梯度是在模型自身定義的機率分佈 `p(x;θ)` 下，對未歸一化對數機率的梯度 `∇_θ log p̃(x;θ)` 的期望。換句話說，它涉及到從模型中採樣，並計算這些樣本對梯度的貢獻。

**Q:** 在使用能量函數 `E(x;θ)` 參數化模型時，正相和負相在直觀上可以如何解釋？
**A:** 如果 `log p̃(x;θ) = -E(x;θ)`，那麼：
*   **正相:** 對應於 `∇_θ (-E(x;θ))`。在梯度上升中，這會試圖調整參數以降低訓練數據點 `x` 的能量。
*   **負相:** 對應於 `- E_{x'~p(x';θ)}[∇_θ (-E(x';θ))]`。在梯度上升中，這會試圖調整參數以提高從模型分佈 `p(x';θ)` 中採樣得到的點 `x'` 的能量。
直觀上，學習過程試圖將機率質量集中在訓練數據點周圍（降低其能量），同時將機率質量從模型自身認為高機率的區域（幻想粒子）移開（提高其能量）。

---

## 18.2 隨機最大概似和對比散度

**重點摘要:**
計算負相梯度 `E_{x'~p(x';θ)}[∇_θ log p̃(x';θ)]` 需要從模型 `p(x;θ)` 中採樣，這通常是困難的。
*   **朴素MCMC方法 (算法18.1):** 一種朴素方法是每次計算梯度時，都從隨機初始化開始運行一組馬爾可夫鏈蒙特卡洛 (MCMC) 採樣器，直到鏈「混合」(burn-in) 以獲得近似的模型樣本。這種方法計算代價極高，實際中不可行，但構成了更實用算法的基礎。
*   **MCMC 的直觀解釋:** 最大化概似的 MCMC 方法可以視為在兩種力之間平衡：一種力拉高數據出現時的模型分佈（正相），另一種力拉低模型採樣出現時的模型分佈（負相，對應最小化 `log Z`）。負相常被稱為「幻覺」或「幻想粒子」。
*   **對比散度 (Contrastive Divergence, CD-k) (算法18.2):** 為了解決朴素 MCMC 方法的計算代價問題，Hinton (2000, 2010) 提出了對比散度。CD-k 算法在每個梯度步驟中，將 MCMC 鏈初始化為從數據分佈中採樣的樣本，然後僅運行 `k` 個 Gibbs 步驟（`k` 通常很小，如 1 到 20）。雖然 CD 是有偏的估計（會收斂到與最大概似估計不同的點），但它在訓練淺層網絡（如 RBM）時非常有用，可以作為初始化更深模型的有效方法。CD 算法不能很好地抑制遠離真實訓練樣本的高機率區域（虛假模態）。
*   **隨機最大概似 (Stochastic Maximum Likelihood, SML) / 持續性對比散度 (Persistent Contrastive Divergence, PCD-k) (算法18.3):** 另一種策略是在每個梯度步驟中，將 MCMC 鏈初始化為上一個梯度步驟結束時的狀態，而不是從數據點重新開始。只要學習率足夠小，模型變化不大，鏈就能保持在接近模型分佈的狀態，從而減少混合時間。SML/PCD 比 CD 更不容易形成虛假模態，並且能更有效地訓練深度模型。然而，評估 SML/PCD 訓練的模型的採樣質量時需要小心，因為用於訓練的鏈可能受到模型最近版本的影響。
*   **快速持續性對比散度 (Fast Persistent Contrastive Divergence, FPCD):** 一種加速混合的方法，通過引入額外的「快速」權重來暫時改變模型參數，促使 MCMC 鏈探索新的區域。

**Q&A:**
**Q:** 計算對數概似梯度的負相為什麼通常很困難？朴素的 MCMC 方法有什麼問題？
**A:** 負相需要計算在模型分佈 `p(x;θ)` 下的期望，這通常需要從 `p(x;θ)` 中進行採樣。如果 `p(x;θ)` 是一個複雜的、高維的分佈，直接採樣是很困難的，通常需要 MCMC 方法。
    朴素的 MCMC 方法（如算法 18.1）的問題在於，每次計算梯度時，都需要從隨機初始狀態開始運行 MCMC 鏈，並等待其「混合」以達到平穩分佈，這個混合過程計算代價非常高，使得訓練過程極其緩慢，在實際中不可行。

**Q:** 什麼是對比散度 (CD-k) 算法？它是如何工作的？它相對於朴素 MCMC 有什麼優點和缺點？
**A:** 對比散度 (CD-k) 是一種近似計算負相梯度的算法。
*   **工作原理:** 在每個梯度計算步驟中，CD-k 將 MCMC 鏈的初始狀態設置為從當前小批量訓練數據中採樣的樣本，然後只運行 `k` 個 MCMC 步驟（例如 Gibbs 採樣步驟，`k` 通常很小）。最後一步的樣本被用來估計負相的期望。
*   **優點:** 計算效率遠高於朴素 MCMC，因為它避免了長時間的混合過程。
*   **缺點:**
    *   **有偏估計:** CD-k 是對真實梯度的有偏估計，它會收斂到與最大概似估計不同的參數點。
    *   **虛假模態 (Spurious Modes):** CD-k 可能無法有效地抑制模型分佈中遠離訓練數據的高機率區域（即虛假模態），因為 MCMC 鏈從數據點開始，運行步數較少，可能無法探索到這些遠離數據的模態。

**Q:** 什麼是隨機最大概似 (SML) 或持續性對比散度 (PCD)？它與 CD 有何不同？它有哪些優勢？
**A:** 隨機最大概似 (SML) 或持續性對比散度 (PCD) 是另一種近似計算負相梯度的 MCMC 策略。
*   **與 CD 的不同:** PCD 不會在每個梯度步驟中都從數據點重新初始化 MCMC 鏈，而是讓 MCMC 鏈在整個學習過程中持續運行，即當前梯度步驟的 MCMC 鏈的初始狀態是上一個梯度步驟結束時鏈的狀態。
*   **優勢:**
    *   **更好的探索:** 由於鏈持續運行，它可以探索更廣闊的狀態空間，更容易發現並抑制模型中的虛假模態。
    *   **更接近真實負相:** 理論上，如果學習率足夠小，持續的鏈能更好地近似從當前模型分佈中採樣，從而得到更準確的負相梯度估計。
    *   **適用於深度模型:** PCD 比 CD 更適合訓練深度模型，因為它能為隱藏單元提供持續的初始值，而 CD 只能為可見單元提供初始化。

**Q:** 為什麼說使用 CD 訓練的模型從某種程度上類似於訓練自編碼器？
**A:** 因為 CD 算法使用訓練數據點來初始化 MCMC 鏈以生成負相樣本。這意味著負相樣本相對接近真實數據。學習過程試圖區分真實數據和這些「輕微擾動」的數據。從這個角度看，模型被激勵去學習如何從這些接近數據的「幻想粒子」中重建或區分出真實數據，這與自編碼器學習從損壞的輸入中重建原始輸入有相似之處。特別是，它有助於預訓練之後會堆疊起來的淺層模型，因為堆疊中最早的模型會受激勵複製更多的信息到其潛變量，使其可用於隨後的模型。

---

## 18.3 偽概似

**重點摘要:**
偽概似 (Pseudolikelihood) 是一種避免直接處理配分函數及其梯度的訓練方法。它基於一個觀察：無向機率模型中條件機率的比率可以消去配分函數。
`p(a|b) = p̃(a,b) / p̃(b) = p̃(a,b) / Σ_{a',c'} p̃(a',b,c')` (公式 18.18)
對數概似 `log p(x)` 可以通過鏈式法則分解為一系列條件對數概似之和 `log p(x) = Σ_i log p(x_i | x_{<i})` (公式 18.19)。計算每個 `log p(x_i | x_{<i})` 仍然需要邊緣化，計算代價高。
偽概似則最大化一個替代目標函數，即所有單個變數 `x_i` 在給定所有其他變數 `x_{-i}` 的條件下的對數機率之和：
`Σ_{i=1}^n log p(x_i | x_{-i})` (公式 18.20)
計算 `p(x_i | x_{-i})` 只需要估計與 `x_i` 取不同值相關的 `p̃(x)` 的值，計算量遠小於計算完整的配分函數。最大化偽概似的估計是漸近一致的。
廣義偽概似 (Generalized Pseudolikelihood Estimator, GPLE) (公式 18.21) 權衡計算複雜度和與最大概似表現的偏差，它條件化變數的一個子集 `x_{-S^(j)}` 來預測另一個子集 `x_{S^(j)}`。偽概似的一個弱點是它不能與僅在 `p̃(x)` 上提供下界的方法（如變分推斷）一起使用。

**Q&A:**
**Q:** 什麼是偽概似 (Pseudolikelihood) 估計？它的基本思想是什麼？
**A:** 偽概似估計是一種用於訓練機率模型的參數估計方法，它避免了計算難以處理的配分函數。其基本思想是最大化數據中每個變數 `x_i` 在給定所有其他變數 `x_{-i}` 的條件下的對數機率之和，即 `Σ_i log p(x_i | x_{-i})`。由於條件機率 `p(x_i | x_{-i}) = p̃(x) / Σ_{x'_i} p̃(x'_i, x_{-i})` 的分母（局部配分函數）只涉及到對單個變數 `x_i` 的求和，其計算通常比完整配分函數容易得多。

**Q:** 相較於計算真實的對數概似，計算偽概似的計算優勢在哪裡？
**A:** 計算真實的對數概似（例如通過鏈式法則 `Σ_i log p(x_i | x_{1:i-1})`）需要對越來越多的變數進行邊緣化，計算量巨大。而計算偽概似中的每一項 `log p(x_i | x_{-i})`，其分母（歸一化項）只需要對單個變數 `x_i` 的所有可能取值進行求和（或積分），計算量顯著降低。如果每個變數有 `k` 個不同的值，`n` 個變數，計算 `p̃` 需要 `k^n` 次估計，而計算偽概似只需要 `n * k` 次 `p̃` 的估計。

**Q:** 偽概似估計的統計特性如何？它有哪些局限性？
**A:**
*   **統計特性:** 最大化偽概似的估計是漸近一致的，即在數據集趨向無窮大時，它會收斂到真實參數。但在有限數據集下，其結果可能與最大概似估計不同。
*   **局限性:**
    *   **性能:** 對於完全聯合分佈 `p(x)` 的任務（如密度估計和採樣），偽概似的表現通常不如最大概似。但在只需要使用條件分佈的任務（如填充少量缺失值）上，效果可能更好。
    *   **與變分推斷不兼容:** 偽概似涉及到 `p̃(x)` 出現在分母中。如果我們只有 `p̃(x)` 的下界（例如通過變分推斷得到），那麼這個下界無法直接用於偽概似的計算（分母的下界會導致整個表達式的上界，而最大化上界沒有意義）。

---

## 18.4 得分匹配和比率匹配

**重點摘要:**
*   **得分匹配 (Score Matching):** (Hyvärinen, 2005b) 提供了另一種無需估計 `Z` 或其導數的訓練方法。「得分」是指對數密度關於**輸入**的梯度 `∇_x log p(x)`。得分匹配最小化模型對數密度得分與數據對數密度得分之間的平方差期望 (公式 18.22)。由於 `∇_x Z(θ) = 0`（因為 `Z` 不是 `x` 的函數），這避免了配分函數的難題。並且，最小化該目標等價於最小化 `E_{p_data}[ Σ_j ( (∂^2/∂x_j^2)log p̃_model(x;θ) + (1/2)(∂/∂x_j log p̃_model(x;θ))^2 ) ]` (公式 18.25)。得分匹配不適用於離散數據，且需要 `log p̃(x)` 及其二階導數易於計算。
*   **比率匹配 (Ratio Matching):** (Hyvärinen, 2007b) 將得分匹配思想擴展到離散數據（特別是二值數據）。它最小化一個目標函數，該函數涉及到模型在某個數據點 `x` 和將 `x` 中某一位 `x_j` 取反後得到的 `f(x,j)` 處的未歸一化機率的比率 (公式 18.26)。配分函數在這個比率中被消掉。比率匹配在去噪任務上效果優於 SML、偽概似和 GSM。

**Q&A:**
**Q:** 什麼是「得分 (score)」？得分匹配的目標是什麼？
**A:** 「得分」是指對數機率密度 `log p(x)` 關於其輸入 `x` 的梯度，即 `∇_x log p(x)`。
    得分匹配的目標是最小化模型預測的得分 `∇_x log p_model(x;θ)` 與真實數據分佈的得分 `∇_x log p_data(x)` 之間的平方差的期望 (公式 18.22)。

**Q:** 得分匹配如何避免了計算配分函數 `Z(θ)` 的難題？
**A:** 因為配分函數 `Z(θ)` 不依賴於輸入 `x`，所以 `∇_x log Z(θ) = 0`。因此，`∇_x log p(x;θ) = ∇_x log p̃(x;θ)`，得分匹配的目標函數中只涉及到未歸一化對數機率 `log p̃(x;θ)` 關於 `x` 的梯度，從而避免了與 `Z(θ)` 相關的計算。

**Q:** 比率匹配是如何擴展得分匹配的思想來處理離散數據的？
**A:** 比率匹配利用了與偽概似類似的策略，即通過考慮機率的比率來消除配分函數。具體來說，它最小化一個目標函數，該函數基於模型在某個（二值）數據點 `x` 處的未歸一化機率 `p̃_model(x;θ)` 與將 `x` 中某一位 `x_j` 翻轉後得到的點 `f(x,j)` 處的未歸一化機率 `p̃_model(f(x,j);θ)` 之間的關係 (如公式 18.26 的形式)。由於配分函數在比率 `p̃_model(x;θ) / p̃_model(f(x,j);θ)` 中被消掉，因此避免了計算 `Z(θ)`。

---

## 18.5 去噪得分匹配

**重點摘要:**
在實踐中，我們通常無法獲取真實的數據分佈 `p_data`，只有其經驗分佈。為了避免模型過擬合到訓練點（即 `p_model` 變成以訓練點為中心的 Dirac 分佈的混合），可以擬合一個平滑後的數據分佈 `p_smoothed(x) = ∫ p_data(y)q(x|y)dy` (公式 18.27)，其中 `q(x|y)` 是一個損壞過程（例如向 `y` 添加少量噪聲）。這被稱為去噪得分匹配。一些自編碼器訓練算法（如第 14.5.1 節討論的）等價于得分匹配或去噪得分匹配，因此它們也是解決配分函數問題的一種方式。

**Q&A:**
**Q:** 什麼是去噪得分匹配？它試圖解決標準得分匹配的什麼問題？
**A:** 去噪得分匹配是得分匹配的一種變體，它不是直接去匹配真實數據分佈 `p_data` 的得分，而是去匹配一個被輕微「損壞」或「平滑」後的數據分佈 `p_smoothed(x) = ∫ p_data(y)q(x|y)dy` 的得分，其中 `q(x|y)` 是一個已知的損壞過程（例如，向 `y` 添加高斯噪聲得到 `x`）。
    它試圖解決的問題是，當我們只有來自 `p_data` 的有限樣本時，標準得分匹配（以及任何一致的估計器）在給定足夠容量的情況下，可能會過擬合到訓練數據，使得 `p_model` 變成一組以訓練點為中心的 Dirac 函數的混合。通過擬合一個平滑後的分佈，有助於緩解這種過擬合，並學習到更平滑、更泛化的密度模型。

**Q:** 去噪得分匹配與某些自編碼器的訓練算法有何關聯？
**A:** 一些自編碼器的訓練算法，特別是那些涉及到從損壞的輸入中重建原始輸入的算法（如去噪自編碼器），其目標函數在某些條件下被證明等價于（或與）得分匹配或去噪得分匹配的目標函數。這意味著這些自編碼器實際上也在隱式地學習數據的某種形式的得分函數，從而也提供了一種繞過配分函數問題來學習數據分佈的方法。

---

## 18.6 噪聲對比估計

**重點摘要:**
噪聲對比估計 (Noise-Contrastive Estimation, NCE) (Gutmann and Hyvärinen, 2010) 是一種不同的策略，它明確地將模型機率表示為 `log p_model(x) = log p̃_model(x;θ) + c` (公式 18.28)，其中 `c = -log Z(θ)` 被視為一個額外的參數，與 `θ` 一同估計。NCE 將估計 `p(x)` 的無監督學習問題轉化為一個監督學習的二元分類問題。具體來說，引入一個易於估計和採樣的噪聲分佈 `p_noise(x)`。構造一個新的聯合模型，其中一個二元開關變量 `y` 決定我們是從模型生成數據 (`y=1`) 還是從噪聲分佈生成數據 (`y=0`)，且 `P_joint(y=1)=P_joint(y=0)=1/2` (公式 18.29-18.31)。然後，訓練一個邏輯回歸分類器來區分來自真實數據（標記為 `y=1`，其來源假設為 `p_model`）和來自噪聲分佈（標記為 `y=0`）的樣本。這個邏輯回歸的對數機率差恰好是 `σ(log p̃_model(x) - log p_noise(x))` (公式 18.37，這裡 `log p̃_model(x)` 包含了可學習的常數 `c`)。通過最大化這個監督學習問題的概似，可以得到 `θ` 和 `c` 的一致估計。
自對比估計 (self-contrastive estimation) 是 NCE 的一種特殊情況，其中噪聲分佈由模型自身的前一個版本生成。

**Q&A:**
**Q:** 噪聲對比估計 (NCE) 的核心思想是什麼？它如何將無監督的密度估計問題轉化？
**A:** NCE 的核心思想是將學習目標模型 `p_model(x)` 的無監督問題轉化為一個監督式的二元分類問題。它引入一個已知的、易於採樣的「噪聲」分佈 `p_noise(x)`。然後，訓練一個分類器來區分來自真實數據（被認為是由 `p_model(x)` 生成的）的樣本和來自噪聲分佈 `p_noise(x)` 的樣本。通過優化這個分類器的參數（包括模型 `p_model` 的參數和一個與配分函數相關的常數），可以得到對 `p_model` 參數的一致估計。

**Q:** 在 NCE 中，模型 `p_model(x)` 和噪聲分佈 `p_noise(x)` 如何構成一個邏輯回歸問題的輸入？
**A:** NCE 構造了一個聯合模型，其中一個二元標籤 `y` 指示樣本 `x` 是來自模型 (`y=1`) 還是來自噪聲 (`y=0`)。給定一個樣本 `x`，判斷其標籤為 `y=1` 的條件機率（即邏輯回歸的輸出）可以表示為：
`P_joint(y=1|x) = p_model(x) / (p_model(x) + p_noise(x))`
如果我們令 `p_model(x) = exp(log p̃_model(x;θ) + c)`，其中 `c` 是一個可學習的常數（近似 `-log Z(θ)`），那麼這個條件機率可以寫成 sigmoid 函數的形式：
`σ( (log p̃_model(x;θ) + c) - log p_noise(x) )`
這就形成了一個標準的邏輯回歸問題，其輸入特徵是 `log p̃_model(x;θ)` 和 `log p_noise(x)`（或者它們的差），目標是預測二元標籤 `y`。

**Q:** NCE 對噪聲分佈 `p_noise(x)` 有什麼要求？選擇不同的噪聲分佈會如何影響學習過程？
**A:** NCE 要求噪聲分佈 `p_noise(x)` 必須易於估計（計算其密度）和易於從中採樣（以生成負樣本）。
選擇不同的噪聲分佈會影響學習過程的效率：
*   如果 `p_noise` 與真實數據分佈 `p_data` (NCE中用`p_model`近似) 相差太大，那麼分類器很容易就能區分它們，導致 `p_model` 的學習進程緩慢，因為大多數噪聲樣本不會迫使 `p_model` 進行顯著改進。
*   理想情況下，`p_noise` 應該與 `p_model` 有一定的重疊，並且能夠提供有挑戰性的負樣本，從而驅動 `p_model` 學習更精細的數據結構。

---

## 18.7 估計配分函數

**重點摘要:**
儘管許多訓練方法避免計算 `Z(θ)`，但在評估模型、監控訓練性能和比較模型時，估計配分函數本身可能很重要。
*   **比較模型:** 如果知道兩個模型 `M_A` 和 `M_B` 的配分函數比率 `r = Z_B(θ_B) / Z_A(θ_A)`，即使不知道各自的絕對值，也可以比較它們在測試集上的對數概似 (公式 18.39)。
*   **重要性採樣:** 可以使用重要性採樣從一個已知的提議分佈 `p_0(x)`（其配分函數 `Z_0` 已知或易於估計）來估計目標分佈 `p_1(x)` 的配分函數 `Z_1`。`Z_1/Z_0` 的估計是 `(1/K) Σ_{k=1}^K [p̃_1(x^(k)) / p̃_0(x^(k))]`，其中 `x^(k) ~ p_0` (公式 18.44, 18.45)。如果 `p_0` 和 `p_1` 相差很大，該估計方差會很大。
*   **退火重要性採樣 (Annealed Importance Sampling, AIS):** (Neal, 2001) 為了解決 `p_0` 和 `p_1` 相差很大的問題，AIS 引入一系列中間分佈 `p_{η_j}` (公式 18.50)，從 `p_0` 平滑過渡到 `p_1`。通過估計相鄰中間分佈之間的配分函數比率並將它們連乘 (公式 18.49)，可以得到 `Z_1/Z_0` 的估計。AIS 使用 MCMC 轉移算子在中間分佈之間生成樣本。AIS 是估計無向模型配分函數的最常用方法之一。
*   **橋式採樣 (Bridge Sampling):** (Bennett, 1976) 依賴於單個「橋」分佈 `p*` 在 `p_0` 和 `p_1` 之間插值，通過兩個重要性權重期望的比率來估計 `Z_1/Z_0` (公式 18.62)。最優的橋式採樣 `p*` 依賴於未知的 `Z_1/Z_0`，但可以從粗糙的 `r` 開始迭代改進。
*   **鏈接重要性採樣:** (Neal, 2005) 結合了 AIS 和橋式採樣的優點。
*   **訓練期間估計 `Z`:** Desjardins et al. (2011) 設計了一種在訓練 RBM 過程中追踪其配分函數的方法，結合了橋式採樣、短鏈 AIS 和並行回火。

**Q&A:**
**Q:** 為什麼即使在訓練時可以避免計算配分函數，估計配分函數仍然很重要？
**A:** 估計配分函數在以下情況下可能很重要：
1.  **模型評估:** 計算模型在測試數據上的真實歸一化概似，這是評估模型擬合優度的一個關鍵指標。
2.  **監控訓練性能:** 追踪配分函數的變化可以幫助了解訓練過程的穩定性和進展。
3.  **模型比較:** 比較不同模型在相同數據集上的對數概似時，需要知道它們的配分函數（或者至少是它們的比率）。

**Q:** 什麼是退火重要性採樣 (AIS)？它是如何工作的？
**A:** 退火重要性採樣 (AIS) 是一種用於估計兩個機率分佈（一個是易於處理的起始分佈 `p_0`，其配分函數 `Z_0` 已知；另一個是目標分佈 `p_1`，其配分函數 `Z_1` 待估計）的配分函數比率 `Z_1/Z_0` 的方法。
*   **工作原理:** AIS 構造一系列中間分佈 `p_{η_0}, p_{η_1}, ..., p_{η_n}`，其中 `p_{η_0} = p_0`，`p_{η_n} = p_1`，這些中間分佈通過一個「退火」參數 `η`（例如，`p_η ∝ p_1^η p_0^{1-η}`）從 `p_0` 平滑地過渡到 `p_1`。然後，AIS 通過重要性採樣估計每對相鄰中間分佈 `p_{η_j}` 和 `p_{η_{j+1}}` 之間的配分函數比率 `Z_{η_{j+1}}/Z_{η_j}`。最後，將所有這些比率連乘起來，得到 `Z_1/Z_0` 的估計：`Z_1/Z_0 = Π_j (Z_{η_{j+1}}/Z_{η_j})`。為了從中間分佈中採樣，AIS 通常使用 MCMC 轉移算子，這些算子被設計為保持相應的中間分佈不變。

**Q:** 橋式採樣與 AIS 在處理起始分佈和目標分佈之間的差異時有何不同？
**A:**
*   **AIS:** 使用一系列多個中間分佈來「橋接」起始分佈 `p_0` 和目標分佈 `p_1` 之間的差距。它通過估計相鄰中間分佈之間的多個比率來工作。
*   **橋式採樣:** 通常依賴於單個「橋」分佈 `p*` 在 `p_0` 和 `p_1` 之間進行插值。它通過計算 `p*` 相對於 `p_0` 的重要性權重期望與 `p*` 相對於 `p_1` 的重要性權重期望的比率來估計 `Z_1/Z_0`。
如果能找到一個與 `p_0` 和 `p_1` 都有很好重疊的 `p*`，橋式採樣可能比 AIS 更高效。但如果 `p_0` 和 `p_1` 相距很遠，找到這樣一個好的單一橋分佈可能很困難，此時 AIS 通過多個中間步驟逐步過渡可能更有優勢。

---
