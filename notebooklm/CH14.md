---
layout: default
title: Deep Learning 101, Taiwan’s pioneering and highest deep learning meetup, launched on 2016/11/11 @ 83F, Taipei 101
---

<p align="center">
  <strong>Deep Learning 101, Taiwan’s pioneering and highest deep learning meetup, launched on 2016/11/11 @ 83F, Taipei 101</strong>  
</p>
<p align="center">
  AI是一條孤獨且充滿惶恐及未知的旅程，花俏絢麗的收費課程或活動絕非通往成功的捷徑。<br>
  衷心感謝當時來自不同單位的AI同好參與者實名分享的寶貴經驗；如欲移除資訊還請告知。<br>
  由 <a href="https://www.twman.org/" target="_blank">TonTon Huang Ph.D.</a> 發起，及其當時任職公司(台灣雪豹科技)無償贊助場地及茶水點心。<br>
</p>  
<p align="center">
  <a href="https://huggingface.co/spaces/DeepLearning101/Deep-Learning-101-FAQ" target="_blank">
    <img src="https://github.com/Deep-Learning-101/.github/blob/main/images/DeepLearning101.JPG?raw=true" alt="Deep Learning 101" width="180"></a>
    <a href="https://www.buymeacoffee.com/DeepLearning101" target="_blank"><img src="https://cdn.buymeacoffee.com/buttons/v2/default-red.png" alt="Buy Me A Coffee" style="height: 100px !important;width: 180px !important;" ></a>
</p>
<p align="center">
  <a href="https://www.youtube.com/@DeepLearning101" target="_blank">YouTube</a> |
  <a href="https://www.facebook.com/groups/525579498272187/" target="_blank">Facebook</a> |
  <a href="https://deep-learning-101.github.io/"> 回 GitHub Pages</a> |
  <a href="http://DeepLearning101.TWMAN.ORG" target="_blank">網站</a> |
  <a href="https://huggingface.co/DeepLearning101" target="_blank">Hugging Face Space</a>
</p>

# 第十四章 自編碼器

<a href="https://www.youtube.com/watch?v=5mrJmzzpPBs" target="_blank" rel="noopener noreferrer"><i class="fab fa-youtube mr-1"></i>2017/09/08, Autoencoders @ Deep Learning Book Chapter 14</a><br>

# 自編碼器 (Autoencoder) 關鍵概念與應用

## 核心目標與基本架構

*   **核心目標：** 自編碼器的主要目標是學習輸入數據的**有效低維編碼表示 (隱藏層)**，並能利用此編碼**準確重構原始輸入** [1-3]。這個過程迫使模型從高維輸入中提取最重要、最具代表性的特徵 [1]。
*   **基本架構：** 由**編碼器 (encoder)** $f(x)$ 將輸入 $x$ 映射到潛在表示 $h$，以及**解碼器 (decoder)** $g(h)$ 從 $h$ 重建輸出 $r$ 組成 [2, 4]。中間層稱為潛在表示或隱藏層 [4]。輸入 $x$ 通過 $f$ 轉換為低維度，再通過 $g$ 變回與原始維度相同 [4]。
*   **訓練目標：** 最小化原始輸入與重建輸出之間的**重構誤差** $L(x, r)$ [1-3, 5]，常用**均方誤差 (Mean Squared Error, MSE)** [2, 4-6]。希望損失函數值越小越好 [5, 6]。訓練過程會調整類似權重的參數來糾正模型 [4]。

## 自編碼器的主要變體

自編碼器可以透過架構約束或在損失函數中增加正則化項來學習更有用的表示：

*   **欠完備自編碼器 (Undercomplete Autoencoder)：**
    *   特點：**隱藏層的維度小於輸入層維度** [1, 2, 4]。
    *   機制：這種架構上的約束**強制模型對輸入數據進行壓縮** [1]，無法簡單複製輸入 [1]。模型被迫學習並保留輸入中最顯著、最有信息的特徵 [1-4]。
    *   效果：有助於捕捉最顯著的特徵 [4]。與非線性 PCA 類似 [2]。不學習過多細節 [4]。範例顯示其成效比 PCA 好，能找出更多特徵 [4]。當使用 MSE 時，轉換方式是線性的 [4]。

*   **稀疏自編碼器 (Sparse Autoencoder)：**
    *   特點：除了重構誤差，還懲罰隱藏層編碼 $h$ 的**非稀疏性** [1, 2, 7]。
    *   機制：主要通過兩種方式誘導稀疏性：
        1.  **L1 正則化：** 在損失函數中添加隱藏單元激活值的 L1 範數 (λ Σ_i |h_i|)，傾向於將許多隱藏單元的激活值**推向或接近零** [1-3, 7, 8]。
        2.  **KL 散度懲罰：** 懲罰隱藏單元的平均激活率與預設的低稀疏度參數之間的 KL 散度，鼓勵模型在處理給定輸入時**只激活少數特定的隱藏單元** [1-3, 7]。
    *   優勢：不能簡單複製輸入，被迫發現數據中更本質、代表性的特徵 [7]。潛在優勢包括**更具可解釋性的特徵**、**更好的泛化能力**，以及**學習到非線性特徵** [7]。即使隱藏層維度很大，也能通過懲罰實現稀疏性 [8]。

*   **去噪自編碼器 (Denoising Autoencoder, DAE)：**
    *   訓練目標：接收一個被**隨機損壞 (加噪)** 的輸入版本 $\tilde{x}$ [2, 3, 5, 9]，並學習**重構原始的、未被損壞的輸入 $x$** [2, 3, 5, 9]。損失函數是 $L(x, g(f(\tilde{x})))$ [2]。
    *   機制：迫使模型學習數據變數之間的依賴關係 [2]，並能從損壞數據中恢復 [2, 5]。
    *   與數據流形關係：DAE 學習從偏離流形點「拉回」到流形上 [2, 3, 9, 10]。學習到的重構方向 $g(f(\tilde{x})) - \tilde{x}$ 可以被視為**估計數據流形在該點的局部切線方向** [2, 3, 9-12]。
    *   與得分估計關係：當噪聲很小時，DAE 的訓練目標近似於學習數據分佈的**得分 (score)**，即 ∇_x log p_data(x) [13, 14]。DAE 學習的重構方向指向數據流形密度增加最快的方向 [14]。
    *   實務考量：訓練時增加噪聲強度可以增強 DAE 的抗噪能力 [6, 15]。過高噪聲可能導致模型學不到東西 [15]。

*   **深度自編碼器 (Deep Autoencoder)：**
    *   特點：編碼器和解碼器包含**多個隱藏層** [2, 3, 15-18]。
    *   優勢：在參數數量相同或相似的情況下，能學習到**更複雜的非線性函數** [3, 15, 16, 19]，用更少參數逼近複雜目標 [3, 15, 16, 18, 19]。能夠學習**層次化特徵** [15, 16, 19]。可以**更有效地將數據壓縮到低維空間** [15, 19]。潛在減少訓練數據量和時間 [3, 15, 16]。將複雜映射分解為多層可能更容易優化 [19]。
    *   訓練：通常採用**逐層預訓練**後進行微調的方式 [2, 18]。一次訓練一層有利於調整函數，再將結果組合 [18]。Universal approximation theorem 相關理論表明增加深度能用更少參數逼近 [18]。

*   **預測稀疏分解 (Predictive Sparse Decomposition, PSD)：**
    *   特點：結合了**稀疏編碼**和**自編碼器**的思想 [2, 16, 20]。不僅尋找稀疏表示，也學習一個編碼器來**直接預測**這個稀疏表示 [2, 16, 20, 21]。
    *   損失函數：包含三個主要部分 [2, 3, 16, 20]：
        1.  **重構誤差項：** 衡量從稀疏編碼重建輸入的準確性 (如均方誤差 ||x - g(h)||^2) [2, 3, 16, 20]。
        2.  **稀疏懲罰項：** 鼓勵學到的編碼稀疏 (如潛在編碼的 L1 範數 λ||h||_1) [2, 3, 16, 20, 21]。
        3.  **預測誤差項：** 衡量編碼器輸出 $f(x)$ 與「理想」稀疏編碼 $h$ 之間的差異 (如 γ||h - f(x)||^2) [2, 3, 16, 20, 21]。
    *   訓練：同時學習字典 (通過解碼器)、稀疏表示、以及預測編碼器 [20, 21]。
    *   應用：用於圖像和視頻中對象識別的**無監督特徵學習** [20, 21]。

*   **收縮自編碼器 (Contractive Autoencoder)：**
    *   機制：通過**懲罰編碼函數對輸入的敏感度** (即導數的大小) 來實現 [12, 17]。在編碼器部分增加正則化項 [12]。
    *   目標：學習能夠捕捉數據本質結構，同時**對無關擾動不敏感**的特徵 [17]。

## 與理論概念的連結

*   **數據流形假設 (Data Manifold Hypothesis)：**
    *   概念：高維數據點實際上集中在一個嵌入在高維空間中的**低維光滑子空間** (流形) 上或其附近 [2, 9-11, 22]。
    *   關係：自編碼器試圖**學習這個低維流形的結構** [10, 11, 22]，學習在高維表示與流形上的低維表示之間轉換 [11, 22]。DAE 通過學習將損壞點拉回流形，間接學習了流形的局部幾何結構 [2, 3, 9, 10, 22]。自編碼器通過學習參數化的映射來學習流形 [11, 23]，與非參數流形學習算法 (如 Isomap, LLE) 不同，後者不學習明確的映射函數，難以處理新數據 [23]。流形在每個點有切平面，DAE 重構方向可近似切平面 [10-12]。

*   **與機率模型的關係：**
    *   確定性自編碼器 (h=f(x), r=g(h)) 可以視為**隨機模型的一種特殊或退化情況** [2, 3, 9, 18]。
    *   確定性解碼器 $r=g(h)$ 可解釋為一個隨機解碼器 $p_{decoder}(x|h)$，其機率質量完全集中在點 $g(h)$ 上 (例如，均值 $g(h)$、方差趨近零的高斯分佈) [3, 9]。
    *   最小化重構誤差可解釋為**最大化條件對數概似** [2, 9]。
    *   這種視角與變分自編碼器 (VAE) 的思想相關聯 [2, 3]。

## 實際應用與實務考量

*   **主要用途：**
    *   **降維與可視化：** 學習低維編碼，用於降低高維數據維度，保留主要結構和特徵，有利於可視化 (例如 MNIST 降維至 2D/3D) [2, 22, 24]。學習到比 PCA 更好的低維嵌入 [22]。
    *   **信息檢索：** 將數據映射到低維潛在空間，使語義相似數據鄰近 [2, 22, 24]。提高檢索效率，例如通過計算距離或使用**語義哈希 (Semantic Hashing)** (將潛在表示二值化作為內存地址) [2, 22, 24]。
    *   **異常檢測：** 訓練重建正常數據，異常數據重構誤差大 [22]。
    *   **生成模型：** 作為 VAE 核心部分 [22]。
    *   **特徵學習：** 作為深度學習模型預訓練步驟 [22]。

*   **實際應用案例 (音頻來源)：**
    *   **APP 推送通知點擊預測：** 利用用戶行為和設備特徵等數據，使用機器學習模型 (如 Random Forest 等，非特指自編碼器) 預測用戶是否會點擊推送，以減少打擾、提高點擊率和轉換率 [22, 25-27]。實務中發現增加數據量有助於提升準確性 [26]。
    *   **二進制文件病毒檢測：** 將二進制文件 (如 APK) 轉換為圖像，利用 CNN (如 InceptionV3) 進行分類檢測 [22, 28-31]。這是一種創新應用，利用圖像識別模型處理非圖像數據 [22, 28]。通過視覺觀察二進制文件轉換的圖像，可能看出不同病毒家族的模式差異 [28, 31]。這類方法有潛力識別傳統方法難以處理的新變種或混淆代碼 [29, 31]。InceptionV3 使用 1x1 卷積來幫助降維和處理多尺度特徵 [29-31]。

*   **實務部署考量 (音頻來源)：**
    *   **模型大小：** 訓練出的模型文件大小 (如 PKL 檔) 會影響部署，尤其在行動裝置或需要快速響應的後端服務 [25-27]。大型模型會導致文件過大 [26]。
    *   **響應時間 (Latency)：** 實際應用常需要在毫秒級內得到預測結果 [26]。大型模型計算耗時，可能無法滿足實時性要求 [26]。處理百萬級用戶請求需要高效的後端架構和快速的模型 [26]。
    *   **訓練資源：** 訓練大型深度學習模型需要大量的數據、計算資源 (高性能 GPU) 和時間 [26, 29, 30]。
    *   **模型效果與大小的權衡：** 有時為了縮小模型大小以符合部署需求，會犧牲一點預測精度，特別是當精度提升非常微小時 [27]。
    *   **數據特性：** 有些數據在標準正則化方法下並無明顯提升 [26]。需要根據數據特性選擇合適的模型和技術 [26, 27]. Random Forest 等模型在某些結構化數據上可能效果更好且訓練快 [27]。
    *   **學術界與業界差異：** 學術界可能更關注算法創新和理想效果，而業界需要考量實際部署的可行性、成本、效率和商業目標 (如是否能帶來收入) [26, 27, 30, 31]。
