# 深度學習模型訓練中的優化 - 整理匯總

## 概述

這份文件彙整了關於深度神經網路模型優化的各類資料。本章探討了深度學習中至關重要的優化問題，特別是神經網路的訓練。與傳統的純優化不同，機器學習中的優化通常是間接的，目標是提高模型在未見數據上的性能（泛化能力），而不是簡單地最小化訓練集上的損失。文件深入介紹了神經網路優化所面臨的挑戰，包括非凸性、病態條件、局部極小值和鞍點等，並回顧了基本優化算法（如 SGD、動量）以及更進階的技術（如自適應學習率方法、參數初始化策略、批標準化、坐標下降、Polyak 平均）和優化策略（如監督預訓練、設計易於優化的模型、課程學習）。

深度學習中最重要的優化問題是**神經網路的訓練**。它的重要性在於模型的性能高度依賴於訓練結果的品質。其挑戰性在於，神經網路模型通常擁有數百萬甚至數十億個參數，且訓練資料集極為龐大，這使得訓練過程需要龐大的計算資源和漫長的時間，即使動用大量機器和數月時間也屬常見。本章主要關注尋找神經網路上的一組參數 θ，使得一個代價函數 J(θ) 顯著降低。這個代價函數通常包含兩部分：一部分是衡量模型在整個訓練集上的性能的指標（如經驗風險），另一部分是額外的正則化項（用於防止過擬合）。

## 機器學習優化與純優化的差異

用於深度模型訓練的優化算法與傳統的優化算法在幾個方面有所不同。

**核心區別:**

1.  **目的不同:** 純優化旨在直接最小化一個特定的目標函數 J。機器學習優化則關註在未知測試集上的效能度量 P（稱為「風險」），這是不可直接優化的。因此，我們轉而間接地優化一個在訓練集上定義的「代價函數 J(θ)」（通常稱為「經驗風險」），希望透過降低訓練誤差來降低真實風險。我們希望通過降低代價函數 J(θ) 來提高 P，這是一個間接的目標。
2.  **目標函數結構:** 機器學習的目標函數通常可以分解為訓練樣本上的總和或平均。 通常，代價函數可以寫為訓練集上的平均。這催生了小批量（Minibatch）等只使用部分資料來估計梯度的方法，這與傳統優化中常用整個資料集計算精確梯度不同。

### 經驗風險最小化 (Empirical Risk Minimization, ERM)

機器學習算法的目標是降低預期的泛化誤差。這個數量被稱為**風險 (risk)**。如果我們知道了真實的數據生成分布 p_data，那麼風險最小化是一個可以通過優化算法解決的問題。然而，我們通常不知道 p_data(x,y)，只知道訓練集中的樣本。我們更希望最小化從數據生成分布 p_data 的期望，而不是僅僅是有限訓練集上的對應目標函數。

將機器學習問題轉化回一個可以用數值優化算法解決的優化問題的最簡單方法是最小化訓練集上的期望損失。這意味著用訓練集上的經驗分布 p̂(x,y) 替代真實分布 p(x,y)。我們將最小化**經驗風險 (empirical risk)**，它指的是模型在**有限訓練數據集**上的平均損失。經驗風險是真實風險的一個經驗估計，用訓練集上的經驗分布 p̂_data 替代了真實分布 p_data。

基於最小化這種平均訓練誤差的訓練過程被稱為**經驗風險最小化 (empirical risk minimization)**。經驗風險最小化（ERM）是一種機器學習策略，目標是找到一組參數 θ，使得這個經驗風險達到最小。

經驗風險最小化與純優化問題的相似之處在於，兩者都是在最小化一個明確定義的目標函數（對於 ERM 來說是經驗風險）。然而，ERM 在機器學習中的最終目標不僅是最小化訓練誤差。更重要的是，希望通過最小化經驗風險，模型也能夠在未見過的數據上表現良好，即具有較低的**真實風險（泛化誤差）**。因此，防止過擬合（即經驗風險很低但真實風險很高）是 ERM 框架下非常重要的考量。我們並不真正關心最優化風險，而是希望在最低經驗風險的同時，也使得真實風險很低。

### 代理損失函數和提前終止

除了標準的目標函數（如經驗風險），機器學習中常用「代理損失函數」和「提前終止」策略。

1.  **代理損失函數 (Surrogate Loss Function):** 當我們真正關心的損失函數（例如分類問題中的 0-1 損失，即錯誤率）因為其數學性質（如不連續、導數為零）而難以直接優化時，我們會轉而優化一個更容易處理的「代理損失函數」。這種函數作為原目標的代理，具備一些優點，例如它是連續可微的，或者其梯度能提供更好的訓練指引。例如，負對數似然/交叉熵損失常用作 0-1 損失的代理。原始損失函數難以優化（離散、非凸、梯度為零）是使用代理損失函數的原因。代理損失函數具有更好的數學性質，更容易被標準優化算法處理。
2.  **提前終止 (Early Stopping):** 這是一種正則化和停止策略。它是一種偏離純優化目標（最小化訓練誤差）的策略。它在訓練過程中監控模型在一個獨立的驗證集上的效能。當模型在訓練集上的損失仍在下降，但驗證集上的損失開始上升（表明模型開始過擬合）時，便停止訓練。這意味著我們返回的不是訓練損失最小的參數，而是泛化性能（在驗證集上衡量的）較好的參數。提前終止不是為了最小化訓練誤差，而是為了找到一個在訓練誤差和泛化能力（由驗證集衡量）之間取得較好平衡的參數。它犧牲了在訓練集上的完美擬合，以換取在未見過數據上更好的表現。

### 批量算法和小批量算法

機器學習算法和一般優化算法不同的一點是，機器學習算法的目標函數通常可以分解為訓練樣本上的求和。優化算法在計算參數的每一次更新時，通常僅使用整個代價函數中的一部分來估計代價函數的期望值。

*   **批量梯度下降 (Batch Gradient Descent):** 使用**整個訓練數據集**來計算每一步的梯度。計算精確，但成本高昂，當訓練集很大時計算成本非常高。
*   **隨機梯度下降 (Stochastic Gradient Descent, SGD):** 每次更新只使用**一個訓練樣本**來計算梯度。有時也指每次使用一個非常小的固定數量的樣本（例如，1個）。計算速度快但梯度估計噪聲大。
*   **小批量隨機梯度下降 (Minibatch SGD):** 介於兩者之間，每次更新使用訓練數據集的一個**小子集（小批量, minibatch）**來計算梯度。小批量的大小通常是一個超參數（例如，32, 64, 128, 256）。這是深度學習中最常用的方法，它在梯度估計的準確性和計算效率之間取得了較好的平衡。

**小批量大小影響:**

*   梯度估計的方差（批量越大，方差越小）。
*   計算效率（太小的批量可能無法充分利用並行計算能力）。
*   內存消耗。
*   某些硬體（如 GPU）對特定大小的批量有性能偏好。

小批量隨機梯度下降 (Minibatch SGD) 的一個重要方面是，如果數據點是獨立同分佈的，那麼從小批量計算得到的梯度期望等於從整個訓練集計算得到的梯度期望。然而，由於小批量樣本的隨機性，梯度的方差較大，這既可能是有益的（幫助跳出局部最優），也可能是有害的（導致收斂不穩定）。獨立同分布假設在實踐中可能不成立，例如當數據點是按順序處理的流數據時，每個新的小批量可能代表了與之前不同的數據分布。

**小批量 SGD 的優缺點 (相比於其他):**

*   **相比於批量梯度下降:**
    *   **優點:** 計算效率高（對於大規模數據集訓練更快）、內存效率高、可能跳出局部最優。
    *   **缺點:** 梯度估計有噪聲、收斂可能不穩定。
*   **相比於（單樣本）隨機梯度下降:**
    *   **優點:** 梯度估計方差更小（優化過程更穩定）、更好地利用並行計算能力（GPU 等）。
    *   **缺點:** 計算量略大，但實際運行時間通常更短。

**在深度學習中被廣泛使用的原因:** 小批量 SGD 在梯度估計的準確性（方差）、計算效率（尤其是在 GPU 上）以及優化過程的穩定性之間提供了一個很好的平衡。

## 神經網路優化中的挑戰

優化神經網路是一個極其困難的任務。傳統的機器學習會小心設計目標函數和約束，以確保優化問題是凸的，從而避免一般非凸優化帶來的複雜性。在神經網路優化中，我們遇到的一般是非凸情況。

在神經網路的非凸優化過程中，會面臨病態（ill-conditioning）、局部極小值（local minima）和鞍點（saddle points）等挑戰。

### 病態 (Ill-conditioning)

在優化凸函數時，會遇到一些挑戰，其中最突出的是 Hessian 矩陣 H 的**病態 (ill-conditioning)**。病態指的是損失函數的 Hessian 矩陣條件數非常大。Hessian 矩陣是目標函數關於參數的二階偏導數矩陣，它描述了目標函數在某一點的局部曲率。條件數是 Hessian 矩陣的最大特徵值與最小特徵值之比。如果條件數很大，則稱 Hessian 矩陣是病態的。病態問題在神經網路訓練過程中普遍存在。

當 Hessian 矩陣病態時，基於梯度的算法（如梯度下降）的表現會很差。這意味著損失函數在某些方向上非常陡峭，在另一些方向上非常平坦。梯度下降在陡峭方向上容易震盪需要小學習率，在平坦方向上進展緩慢，導致整體收斂速度極慢。梯度下降的方向是 -g，而理想的更新方向（如牛頓法）是 -H⁻¹g。如果條件數很大，意味著損失函數的等值線（對於二次函數是橢球）在某些方向上曲率很高（陡峭），而在另一些方向上曲率很低（平坦）。梯度方向通常不會指向最優點。

**負面影響:**

1.  **收斂速度緩慢:** 在陡峭方向上可能震盪需要小學習率；在扁平方向上進展慢。
2.  **對學習率敏感:** 需要設很小的學習率，進一步減慢扁平方向的學習。
3.  **早停於次優解:** 收斂緩慢導致可能提前停止。

### 局部極小值 (Local Minima)

對於凸優化問題，任何局部極小值都是全局極小值。但對於非凸函數（如神經網路的損失函數），可能存在多個局部極小值。優化算法可能陷入一個代價較高（遠離全局最優）的局部極小值而無法逃脫。一旦陷入這樣的局部極小值，標準的梯度下降算法很難從中逃逸出來去尋找更好的解。

然而，對於深度神經網路，一個普遍的觀點是，大多數局部極小值的代價與全局極小值的代價非常接近。真正的挑戰在於那些代價顯著高於全局最小值的局部極小值。

**模型可辨識性 (Model Identifiability)** 問題與局部極小值有關。如果一個模型有多組不同的參數值能夠產生完全相同的輸出（即模型不可辨識），那麼損失函數必然會有許多等價的局部極小值。例如，交換神經網路同一層中兩個隱藏單元的所有權重，模型的輸出不變，這導致了參數空間的**權重空間對稱性 (weight space symmetry)**。這些由不可辨識性導致的局部極小值通常代價相同，不是主要問題。

### 高原、鞍點和其他平坦區域

對於很多高維非凸函數而言，局部極小值（以及極大值）實際上都遠少於另一類梯度為零的點：**鞍點 (saddle points)**。鞍點是目標函數上梯度為零的點，但它既不是局部極小值也不是局部極大值。在鞍點處，某些方向的點比鞍點高，另一些方向的點比鞍點低。其 Hessian 矩陣是不定的，即既有正特徵值也有負特徵值。

多類隨機函數表現出以下性質：低維空間中，局部極小值很常見；高維空間中，局部極小值很罕見，而鞍點則很常見。使得 Hessian 矩陣所有特徵值都為正（形成局部極小值）或都為負（形成局部極大值）的機率隨維度 n 的增加呈指數級下降。使得 Hessian 矩陣既有正特徵值又有負特徵值（形成鞍點）的機率則相對較高。

近年來研究表明，在高維深度神經網路損失函數中，鞍點比代價高的局部極小值更普遍。

**鞍點對優化構成的挑戰:**

*   在高維空間中更普遍。
*   優化算法在鞍點附近梯度接近零，可能長時間停滯，構成比局部極小值更大的挑戰。標準的梯度下降算法在鞍點附近可能會因為梯度過小而進展非常緩慢。
*   逃逸鞍點需要沿著 Hessian 矩陣負特徵值對應的方向移動，而簡單的梯度下降可能無法有效地找到這個方向。

**高原 (Plateaus):** 指的是損失函數表面上一個廣闊的、梯度幾乎為零的平坦區域。它們可以是局部極小值、局部極大值或鞍點的組合，或者僅僅是曲率非常低的區域。在高原上，梯度非常小，導致優化算法進展極其緩慢。

**寬闊的山谷:** 如果損失函數形成一個非常寬闊、底部平坦的山谷，即使梯度不完全為零，也可能導致算法在山谷中緩慢移動或來回震盪。

## 基本優化算法

本節回顧梯度下降法，這是訓練整個訓練集的梯度的下降方向。可以使用隨機梯度下降來極大地加速，沿著隨機挑選的小批量的數據的梯度下降方向。

### 隨機梯度下降 (Stochastic Gradient Descent, SGD)

隨機梯度下降 (SGD) 及其變種很可能是一般機器學習中應用最多的優化算法，特別是在深度學習中。如第 8.1.3 節所討論的，按照數據生成分布抽取 m 個小批量（獨立同分佈的）樣本，通過計算它們梯度的無偏估計。

SGD 算法中的一個關鍵參數是學習率 ϵ_k。學習率 ϵ_k 控制了參數更新的步長。學習率太小收斂慢，太大可能震盪或發散。SGD 收斂的一個充分條件是： Σ_{k=1}^∞ ϵ_k = ∞ 且 Σ_{k=1}^∞ ϵ_k^2 < ∞。這是理論上學習率需要滿足的條件。

**實踐中的學習率衰減策略:**

實踐中，一般會線性衰減學習率直到第 τ 次迭代：ϵ_k = (1-α)ϵ_0 + αϵ_τ，其中 α = k/τ。在 τ 步迭代之後，一般使 ϵ 保持常數。選擇初始學習率 ϵ_0 和最終學習率 ϵ_τ (通常設為 ϵ_0 的 1%) 非常重要。其他常用的衰減策略還包括步進衰減、指數衰減、餘弦退火等。

### 動量 (Momentum)

雖然 SGD 仍然是非常流行且受歡迎的優化方法，但其學習過程有時會很緩慢。**動量 (momentum)** 方法 (Polyak, 1964) 旨在加速學習，特別是處理高曲率、小但一致的梯度，或是帶有噪聲的梯度。

其核心思想是引入一個**速度 (velocity)** 向量 v，該向量積累了過去梯度的指數加權移動平均。參數更新時，不僅考慮當前梯度方向，也受先前積累的速度方向影響。動量算法積累了之前梯度指數級衰減的移動平均，並繼續沿該方向移動。

速度向量 v 被初始化為 0。然後，v 和 θ 的更新規則如下：
v ← αv - ϵ∇_θ( (1/m) Σ_{i=1}^m L(f(x^(i);θ), y^(i)) )
θ ← θ + v
其中 α ∈ [0,1) 是決定之前梯度的貢獻衰減得有多快的超參數（通常設為 0.5, 0.9 或 0.99）。v 類比於物理學中的速度，αv 模擬了阻力。超參數 α 控制了先前速度對當前速度的影響程度。

動量旨在主要解決兩個問題：Hessian 矩陣的病態問題和隨機梯度的方差問題。它有助於在損失函數表面上梯度方向一致的維度上加速，而在梯度方向頻繁改變的維度上（例如在峽谷壁之間）抑制震盪，從而加速收斂並部分緩解 Hessian 病態問題和梯度方差問題。直觀上，可以將優化過程想像成一個滾下山坡的小球，受到坡度和慣性的影響。通過對歷史梯度進行平均，有助於平滑梯度的更新方向。由於慣性的存在，動量更新有時可以幫助優化過程「衝過」一些較淺的局部極小值或鞍點。

### Nesterov 動量 (Nesterov Momentum)

Nesterov 動量 (Nesterov, 1983, 2004; Sutskever et al., 2013) 是標準動量方法的一個變種。其核心區別在於梯度計算的點。在標準動量中，梯度是在當前位置 θ 處計算的。在 Nesterov 動量中，梯度是在參數近似於「下一步將要到達的位置」（即 θ + αv）處計算的。

更新規則如下：
v ← αv - ϵ∇_θ[ (1/m) Σ_{i=1}^m L(f(x^(i);θ + αv), y^(i)) ]
θ ← θ + v
Nesterov 動量可以被看作是試圖在「跳躍」之前「向前看一步」，如果預計跳躍會導致損失增加，就進行修正。在凸批量梯度情況下，Nesterov 動量將誤差率從 O(1/k) 改善到 O(1/k^2)。對於 SGD，它沒有改善收斂率，但實踐中通常表現更好。

直觀解釋是，它在決定最終的更新方向之前，先「試探性地」沿著先前積累的動量方向「跳」一步，然後在那個預測的未來位置評估梯度。這種「向前看」的機制可以提供更及時的修正，幫助算法在接近最優解時減少震盪，理論上在凸優化中能提供更好的收斂率（儘管在非凸情況下理論保證較少，但實踐中常表現更好）。

## 參數初始化策略

訓練深度模型的算法通常是迭代的，因此需要指定參數的初始值。這是一個非常重要的環節。

**重要性原因:**

1.  **打破對稱性 (Symmetry Breaking):** 如果同一層的所有權重初始化為相同值（例如全零），它們將學習到相同的特徵，喪失網路表達能力。隨機初始化是必需的。如果權重都初始化為零，同一層中的所有隱藏單元將會計算得到完全相同的輸出、梯度和更新，永遠學習到相同的特徵。
2.  **影響優化過程:** 好的初始化能讓參數從一個有利於優化、能更快收斂且最終效能更好的區域開始；差的初始化可能導致優化困難、收斂緩慢或陷入差的局部極小值/鞍點。
3.  **控制梯度流動:** 不恰當的初始化（權重過大或過小）可能導致前向傳播時激活值過大或過小，進而在反向傳播時引發梯度爆炸或梯度消失問題。好的初始化策略試圖在網路的不同層之間保持激活值和梯度的方差大致穩定。
4.  **最終模型性能:** 影響最終找到的解的質量和模型的泛化性能.

常用的策略是將權重從一個具有較小方差的隨機分佈（如均勻分佈或高斯分佈）中抽取。偏置通常初始化為零或小的正值（對於 ReLU）。

**常用策略的核心思想:** 為了使信息能夠有效地在深度網路中向前和向後傳播，理想情況下，每一層的輸出激活值的方差應該與其輸入激活值的方差大致相同，並且反向傳播的梯度的方差也應該在各層之間保持相對穩定。

*   **Xavier/Glorot 初始化** (Glorot and Bengio, 2010): 一種權重初始化方法，旨在根據層的輸入和輸出單元數量調整方差，適用於對稱激活函數（如 tanh 或線性激活），幫助緩解梯度消失/爆炸問題。其目標是在前向傳播和反向傳播時都保持方差大致不變。通常將權重從一個均值為 0、方差為 Var(W) = 2 / (fan_in + fan_out) 的分佈中採樣。
*   **He 初始化** (He et al., 2015): 專為 ReLU 及其變體設計，考慮到 ReLU 對方差的影響。通常將權重從一個均值為 0、方差為 Var(W) = 2 / fan_in 的分佈中採樣。其目標是主要確保在前向傳播時激活值的方差保持穩定。

這些初始化方法顯著改善了深度神經網路的訓練穩定性和性能。對於循環網路，初始化循環權重矩陣以使其接近恆等映射有助於學習長期依賴。

## 自適應學習率算法 (Adaptive Learning Rate Methods)

自適應學習率算法為**每個參數獨立地調整其學習率**，而不是使用單一的全局學習率。它們與標準 SGD 的主要區別在於它們根據不同參數的梯度特性自動調整更新步長。

*   **AdaGrad (Adaptive Gradient)** (Duchi et al., 2011): 一種自適應學習率算法。獨立地適應所有模型參數的學習率，縮放每個參數反比於其所有梯度歷史平方值總和的平方根。對於歷史梯度小的參數給予較大的更新，對歷史梯度大的參數給予較小的更新。有利於稀疏特征。主要缺點是分母中的梯度平方和會持續累積，導致學習率最終變得非常小，可能過早停止學習。
*   **RMSProp (Root Mean Square Propagation)** (Hinton, 2012, 未發表): 改進 AdaGrad 的缺點，使用梯度平方的**指數加權移動平均**來調整學習率，避免了學習率過早過小。通過使用指數加權移動平均，RMSProp 使得更近期的梯度平方對 r_t 的影響更大，而較早的梯度平方的影響會隨時間衰減。
*   **Adam (Adaptive Moment Estimation)** (Kingma and Ba, 2014): 結合了動量（使用梯度的一階矩的移動平均）和 RMSProp（使用梯度平方的二階矩的移動平均）的思想。它不僅存儲梯度平方的指數加權移動平均 v（類似 RMSProp），還存儲梯度的指數加權移動平均 m（類似動量）。然後使用 m̂ / (sqrt(v̂) + δ) 來更新參數。它通常被認為是一個非常魯棒且表現良好的預設優化器。

**這些算法的優勢:**

*   能夠根據不同參數的梯度特性自動調整更新步長。
*   通常比手動調整全局學習率的 SGD 更容易使用和達到較好的性能，尤其是在處理高維、非凸的神經網路損失函數時。
*   自適應學習率算法（如 RMSProp, AdaDelta, Adam）通常表現出相似的魯棒性，並且通常比需要手動調整學習率的 SGD 或帶動量的 SGD 更容易使用（即對初始學習率的選擇不那麼敏感）。Adam 通常是一個很好的默認起點。

**選擇正確的優化算法:**

目前還沒有一個公認的「最佳」優化算法。選擇哪種算法取決於具體問題和用戶對超參數的熟悉程度。對多種優化算法的比較表明，沒有單一算法在所有情況下都顯著優於其他算法。

然而，精心調整的 SGD（帶動量和 Nesterov 動量）有時也能達到與自適應方法相當甚至更好的性能，但可能需要更多的超參數搜索。最終，最好的方法通常是通過在驗證集上進行實驗來比較不同算法和超參數設置的性能。

## 二階近似方法

利用 Hessian 矩陣指導優化。

### 牛頓法 (Newton's Method)

牛頓法是一種二階優化算法，它利用目標函數的一階導數（梯度）和二階導數（Hessian 矩陣）來尋找函數的極小值。

參數更新規則：θ* = θ_0 - H⁻¹ ∇_θJ(θ_0)。它直接跳向二次近似的極小點。

**優點:**

*   **快速收斂:** 對於性質好的函數，通常具有二次收斂速度。對於二次函數可以在一步內收斂。
*   **處理病態 Hessian:** 通過乘以 Hessian 的逆來校正梯度方向，可以有效地處理病態問題。

**缺點:**

*   **計算成本高:** 計算、存儲和求逆 Hessian 成本極高 (O(k^2) 或 O(k^3))。對於大型網路不可接受。
*   **Hessian 矩陣可能非正定:** 在非凸區域（如鞍點附近）需要修改才能確保方向指向極小值。

### 共軛梯度法 (Conjugate Gradients)

迭代方法，通過構造共軛方向避免直接計算 Hessian 及其逆。對於二次函數能精確求解，對於非二次函數作為迭代線搜索方法，通常比梯度下降快。

**在非二次優化中的應用:**

在非二次的、一般的非線性優化問題中，共軛梯度法仍然是一種有效的迭代方法，但不再保證在有限步內收斂。通常通過計算 β_t 構造新的搜索方向 d_t，沿著 d_t 進行線搜索找到步長 α_t，更新參數。為了處理非二次性，有時需要定期重置搜索方向為負梯度方向。

### BFGS (Broyden-Fletcher-Goldfarb-Shanno) 和 L-BFGS

**BFGS:** 擬牛頓法，迭代近似 Hessian 逆，無需顯式計算 Hessian。

**L-BFGS:** BFGS 的內存受限版本，只存儲近期歷史信息隱式表示 Hessian 逆近似。適用於參數數量大的問題。

## 優化策略和元算法

優化本身並非真正的算法，而是一般的模板，可以特定地產生算法。這些方法通常是迭代的。

### 批標準化 (Batch Normalization, BN)

批標準化 (Ioffe and Szegedy, 2015) 是一種廣泛使用且非常有效的技術。它不是一個優化算法，而是一種網絡層的設計，有助於改善優化過程和模型的泛化能力。

**核心思想:** 在網路的每一層的仿射變換（Wx+b）之後、非線性激活函數之前，對該層的輸入進行標準化處理，使其具有零均值和單位方差。然後，再通過兩個可學習的參數 γ（縮放因子）和 β（平移因子）對標準化後的值進行仿射變換，以恢復其表示能力。BN 對一個小批量數據在該層的激活值進行操作。計算均值和方差是針對每個 Feature 進行的，而非整個 Input Matrix.

計算過程:
Ĥ = (H - μ) / σ (標準化)
BN(H) = γĤ + β
μ 和 σ^2 是在當前小批量上計算的統計量。γ 和 β 是可學習參數。

**作用:**

1.  **緩解內部協變量偏移 (Internal Covariate Shift):** 深度網路中，由於前一層參數更新導致後續層輸入分布不斷變化，BN 通過標準化使輸入分布穩定。
2.  **加速收斂:** 允許使用更大的學習率，並減少對參數初始化的敏感性。
3.  **正則化效果:** 由於均值和標準差在每個小批量上計算引入噪聲，具有輕微正則化效果。
4.  **避免梯度飽和:** 將激活值保持在較好範圍內，有助於梯度流動。

在測試時，使用整個訓練集（或其移動平均）的均值和方差來進行標準化，而不是測試批次的統計量。這項技術在很多地方都被看到一定會用。

### 坐標下降 (Coordinate Descent)

坐標下降是一種優化策略。它不是同時更新所有參數，而是一次只優化一個參數（或一小組參數，稱為塊坐標下降），同時保持其他參數固定。

**工作原理:**

迭代地遍歷所有參數（或參數塊）。對於當前選擇的參數（塊），找到使其目標函數最小的值（通常通過解析解或簡單的單變量優化），然後更新該參數（塊），再移動到下一個。

**適用情況:**

*   對單個參數（或小子集）的優化非常高效或有閉式解時。
*   參數之間存在某種程度的解耦時。
*   對於某些具有特定結構的問題。
*   目標函數關於每個坐標是凸的時候。

**優點:** 實現簡單，有時非常有效，不需要計算完整的梯度或 Hessian。

**缺點:** 參數之間高度相關時收斂慢，不適用於所有類型的目標函數（如非光滑函數），可能陷入非駐點（對於非凸、非光滑函數）。

### Polyak 平均 (Polyak Averaging)

Polyak 平均（也稱為 Polyak-Ruppert 平均）是一種通過對 SGD 訓練過程中產生的參數迭代序列進行平均，來獲得一個可能更好的最終參數估計的技術。

**應用於 SGD:**

運行標準的 SGD，得到參數序列 θ^(1), ..., θ^(T)。計算這些參數的（加權或非加權）平均值作為最終模型參數，例如簡單平均或指數移動平均 (EMA)。

**改善性能原因:**

*   **減少噪聲的影響:** 平滑掉 SGD 參數軌跡因小批量梯度噪聲引起的震盪。
*   **更好的收斂率（對於凸優化）:** 理論上對於某些凸函數，平均後的解收斂更快。
*   **更穩定的解:** 平均後的參數通常更穩定。

在深度學習的非凸優化中，Polyak 平均（或 EMA）也常用於獲得更平滑的權重更新和可能略好的泛化性能。

### 監督預訓練 (Supervised Pretraining)

監督預訓練是指在訓練目標模型解決最終的、複雜的監督學習任務之前，先使用標註數據訓練該模型（或其一部分）解決一個或多個相關的、通常更簡單的輔助監督學習任務。通過這些輔助任務學到的參數被用作最終任務訓練的初始值。

**與無監督預訓練的區別:** 在於**是否使用標籤信息**。無監督預訓練在無標籤數據上學習數據結構；監督預訓練在帶標籤數據上學習輔助監督任務。

**逐層監督預訓練 (greedy layer-wise supervised pretraining):**

逐步訓練網路的層或子集。首先訓練第一層完成（簡化的）監督任務。固定已訓練層，添加新層並訓練新層完成同一個（或更複雜的）任務。重複直到構建整個網路。最後通常對整個網路進行端到端微調。這種方法是「貪心」的，每次只優化當前層的參數。

**遷移學習中的預訓練:**

例如，在 ImageNet 上預訓練一個圖像分類模型然後用於其他視覺任務，可以被看作是一種非常成功的監督預訓練形式。原因包括源任務（ImageNet 分類）是監督的，通過大規模監督學習學到了通用的視覺特征，這些預訓練好的權重隨後被用作初始化下游任務的模型。

### 設計有助於優化的模型

改進優化的最好方法並非總是改進優化算法。相反，設計一個更易於優化的模型通常更有效。因為優化算法的性能在很大程度上取決於它所要優化的目標函數的「景觀」。

通過改進模型的架構設計，我們可以改善損失景觀（更平滑、減少差的極小值/鞍點），促進梯度流動（避免梯度消失/爆炸），簡化優化問題。一個更易於優化的模型架構本身就可以讓相對簡單的優化算法也能取得好結果。

**示例:**

*   **線性變換鏈的梯度問題:** 在非常深的、僅包含線性變換的模型中，梯度很容易消失或爆炸。
*   **跳躍連接 (Skip Connections) / 殘差連接 (Residual Connections):** (Srivastava et al., 2015; He et al., 2016 - ResNet)。引入從較淺層到較深層的直接連接，允許信息和梯度「跳過」中間層。這使得可以訓練非常深的網路，並顯著緩解了梯度消失問題。它們為梯度提供了一條「捷徑」。此外，使得更容易學習恆等映射。
*   **批標準化 (Batch Normalization):** 也有助於優化。
*   **將優化問題分解:** 例如引入輔助損失函數指導中間層學習。

### 延拓法 (Continuation Method) 和 課程學習 (Curriculum Learning)

**延拓法:** 一種通用的優化策略，從一個更容易解決的問題版本開始，然後逐漸將問題變形為原始的、更困難的問題，同時使用前一個較易問題的解作為下一個更難問題的初始值。

**課程學習 (Bengio et al., 2009):** 是延拓法在機器學習中的一個實例。它模仿人類學習的方式，先向模型展示更容易的樣本或更簡單的任務，然後逐漸增加難度。

**形式:**

*   **樣本排序:** 按照難度對訓練樣本排序，先用容易的樣本訓練，再逐步引入困難的樣本。
*   **任務簡化:** 先訓練模型解決簡化版本的任務，再遷移到完整任務。

**好處:**

*   **加速收斂:** 從簡單樣本開始，模型更快掌握基本模式。
*   **改善泛化和最終性能:** 循序漸進的過程可能更容易找到泛化好的解。
*   **避免差的局部最優:** 從更容易的損失景觀開始優化。

## 常見問答匯總 (來自 CH8-常見問答)

*   **什麼是深度學習中最核心的優化問題？它為何如此具有挑戰性？** 深度學習中最核心且代價高昂的優化問題是**神經網路的訓練**。其重要性在於模型的效能高度依賴於訓練結果的品質。挑戰性在於，神經網路模型通常擁有數百萬甚至數十億個參數，且訓練資料集極為龐大，這使得訓練過程需要龐大的計算資源和漫長的時間，即使動用大量機器和數月時間也屬常見。
*   **機器學習中的優化與純粹的數學優化有何主要區別？** 機器學習中的優化與純粹的數學優化在於其目的和方法：1. **間接優化：**機器學習的終極目標是最小化在未知測試集上的效能度量 P（稱為「風險」），這通常是不可直接優化的。因此，我們轉而間接地優化一個在訓練集上定義的「代價函數 J(θ)」（通常稱為「經驗風險」），希望透過降低訓練誤差來降低真實風險。純粹的數學優化則直接以最小化目標函數 J 本身為目的。2. **目標函數結構：**機器學習的目標函數通常可以分解為訓練樣本上的總和或平均，這催生了小批量（Minibatch）等只使用部分資料來估計梯度的方法，這與傳統優化中常用整個資料集計算精確梯度不同。
*   **什麼是經驗風險最小化（Empirical Risk Minimization, ERM）？它在機器學習中的最終目標是什麼？** 經驗風險（Empirical Risk）是指模型在**有限訓練數據集**上的平均損失。經驗風險最小化（ERM）是一種機器學習策略，目標是找到一組參數 θ，使得這個經驗風險達到最小。 然而，ERM 在機器學習中的最終目標不僅是最小化訓練誤差。更重要的是，希望通過最小化經驗風險，模型也能夠在未見過的數據上表現良好，即具有較低的**真實風險（泛化誤差）**。因此，防止過擬合（即經驗風險很低但真實風險很高）是 ERM 框架下非常重要的考量。
*   **除了標準的目標函數（如經驗風險），機器學習中常用的「代理損失函數」和「提前終止」策略各自的目的是什麼？** 1. **代理損失函數（Surrogate Loss Function）：**當我們真正關心的損失函數因為其數學性質而難以直接優化時，我們會轉而優化一個更容易處理的「代理損失函數」。代理損失函數通常被設計為連續可微，且其梯度能為優化提供更好的指引。 2. **提前終止（Early Stopping）：**這是一種正則化和停止策略。它在訓練過程中監控模型在一個獨立的驗證集上的效能。當模型在訓練集上的損失仍在下降，但驗證集上的損失開始上升時，便停止訓練。提前終止不是為了最小化訓練誤差，而是為了找到一個在訓練誤差和泛化能力之間取得較好平衡的參數。
*   **在神經網路的非凸優化過程中，病態（ill-conditioning）、局部極小值（local minima）和鞍點（saddle points）分別帶來什麼挑戰？** 1. **病態：**指的是損失函數的 Hessian 矩陣條件數非常大。導致整體收斂速度極慢。 2. **局部極小值：**可能陷入一個代價較高的局部極小值而無法逃脫。 3. **鞍點：**在高維深度神經網路損失函數中，鞍點比代價高的局部極小值更普遍，構成比局部極小值更大的挑戰。
*   **動量（Momentum）和 Nesterov 動量方法的核心思想是什麼？它們如何幫助改善隨機梯度下降（SGD）的收斂性？** 1. **動量：**引入一個「速度」向量 v，積累了過去梯度的指數加權移動平均。這有助於在梯度方向一致的維度上加速，並在梯度方向頻繁變化的維度上抑制震盪，從而加速收斂並部分緩解 Hessian 病態問題和梯度方差問題。 2. **Nesterov 動量：**其關鍵區別在於，它不是在當前參數位置計算梯度，而是在「預測的」未來位置計算梯度。這種「向前看」的機制可以提供更及時的修正，理論上在凸優化中能提供更好的收斂率。
*   **為什麼神經網路的參數初始化非常重要？不良的初始化會帶來哪些問題？** 參數初始化策略極為重要，原因如下：1. **打破對稱性：**如果同一層的所有權重初始化為相同值，它們將學習到相同的特徵。隨機初始化是必需的。2. **影響優化過程：**好的初始化能讓參數從一個有利於優化、能更快收斂且最終效能更好的區域開始；差的初始化可能導致優化困難。3. **控制梯度流動：**不恰當的初始化可能導致前向傳播時激活值過大或過小，進而在反向傳播時引發梯度爆炸或梯度消失問題。
*   **什麼是自適應學習率算法（Adaptive Learning Rate Methods），例如 AdaGrad、RMSProp 和 Adam？它們與標準 SGD 的主要區別和優勢是什麼？** 自適應學習率算法為**每個參數獨立地調整其學習率**，而不是使用單一的全局學習率。它們的優勢在於能夠根據不同參數的梯度特性自動調整更新步長，通常比手動調整全局學習率的 SGD 更容易使用和達到較好的性能。
    *   **AdaGrad：**根據每個參數歷史梯度的平方和來縮放學習率。適用於稀疏數據。缺點是學習率持續單調下降，可能導致學習過早停止。
    *   **RMSProp：**為了解決 AdaGrad 的問題，使用梯度平方的**指數加權移動平均**來調整學習率，避免了學習率過早過小。
    *   **Adam：**結合了動量和 RMSProp 的思想。它通常被認為是一個非常魯棒且表現良好的預設優化器。

## 時間軸和主要人物

這份時間軸主要涵蓋了神經網路優化領域中概念和算法的提出與發展。來源主要側重於概念解釋和它們之間的關係，具體的年份資訊相對有限，部分時間點是根據概念被討論的順序和已知研究背景推斷。這份時間軸是根據來源中提到的概念和作者大致整理，某些事件的精確年份可能需要查閱原始論文以確認。來源側重於概念的演進和相互影響，而非嚴格的歷史記錄。

#### 詳細時間軸

*   **未知時間點前（理論基礎時期）**
    *   存在純粹的數學優化理論。
    *   可能已存在基於梯度的優化算法，如批量梯度下降。
    *   可能已存在隨機梯度下降 (SGD) 的基本概念，但當時可能尚未在大型模型訓練中廣泛應用。
    *   可能已存在關於非凸優化中局部極小值、鞍點、病態 Hessian 等挑戰的初步認識。
*   **1964年：** Polyak 提出動量方法（Momentum）。
*   **1983年, 2004年：** Nesterov 提出 Nesterov 動量（Nesterov Momentum）。
*   **2010年：** Glorot 和 Bengio 提出 Xavier/Glorot 初始化。
*   **2011年：** Duchi 等人提出 AdaGrad（Adaptive Gradient）。
*   **2012年：** Hinton（未發表工作）提出 RMSProp（Root Mean Square Propagation）。
*   **2014年：** Kingma 和 Ba 提出 Adam（Adaptive Moment Estimation）。
*   **2015年：** Ioffe 和 Szegedy 提出批標準化（Batch Normalization, BN）。Srivastava 等人（可能指 Highway Networks 或其他相關工作）提出跳躍連接或類似概念。
*   **2016年：** He 等人提出殘差網路（ResNet），推廣了殘差連接（Residual Connections）。He 也在 2015 年提出了 He 初始化方法。
*   **近年來（Ongoing Research）**
    *   對高維空間中鞍點的研究增多。
    *   對各種優化算法（包括自適應方法）的理論行為、收斂性、泛化能力等進行持續的研究和比較，但仍有很多實踐中的觀察缺乏完整的理論根據。
    *   延拓法和課程學習等元算法在機器學習中的應用被探討。
    *   新的優化算法和改進不斷出現。

#### 主要人物列表

根據提供的來源，以下是其中提到的主要人物及其簡要介紹：

1.  **Polyak:** 於 1964 年提出了動量（Momentum）方法。
2.  **Nesterov:** Yurii Nesterov，於 1983 年和 2004 年提出了 Nesterov 動量方法（Nesterov Momentum）。
3.  **Glorot:** Xavier Glorot，與 Bengio 共同在 2010 年提出了 Xavier/Glorot 初始化方法。
4.  **Bengio:** Yoshua Bengio，深度學習領域的「三巨頭」之一，與 Glorot 共同提出了 Xavier/Glorot 初始化方法。他在深度學習領域有廣泛且深遠的貢獻。
5.  **Duchi:** John Duchi，與他人共同在 2011 年提出了 AdaGrad（Adaptive Gradient）算法。
6.  **Hinton:** Geoffrey Hinton，深度學習領域的「三巨頭」之一，被譽為「深度學習教父」。提出了 RMSProp（Root Mean Square Propagation）算法（未發表）。他在神經網路和深度學習領域有許多開創性的工作。
7.  **Kingma:** Diederik P. Kingma，與 Ba 共同在 2014 年提出了 Adam（Adaptive Moment Estimation）算法。
8.  **Ba:** Jimmy Ba，與 Kingma 共同在 2014 年提出了 Adam（Adaptive Moment Estimation）算法。
9.  **Ioffe:** Sergey Ioffe，與 Szegedy 共同在 2015 年提出了批標準化（Batch Normalization）技術。
10. **Szegedy:** Christian Szegedy，與 Ioffe 共同在 2015 年提出了批標準化（Batch Normalization）技術。
11. **Srivastava:** Rupesh Kumar Srivastava，可能指與 Highway Networks 或類似引入跳躍連接概念相關的工作。
12. **He:** Kaiming He，在 2015 年提出了 He 初始化方法。此外，他是 2016 年提出殘差網路（ResNet）的主要貢獻者之一。
13. **Schaul:** Tom Schaul，與他人 (Schaul et al., 2014) 對多種優化算法進行了比較研究。

這些人物是神經網路優化領域中提出重要概念和算法的關鍵貢獻者。

## 研讀指南 - 測驗與申論題

這部分提供了深度學習模型優化研究的指引。

#### 測驗 (Quiz)

請用 2-3 句話簡短回答以下問題：
1.  深度學習中最重要的優化問題是什麼？它為何具有挑戰性？
2.  機器學習中的「風險」和「經驗風險」有什麼區別？我們為什麼要最小化經驗風險？
3.  代理損失函數 (surrogate loss function) 是什麼？為什麼有時需要使用它來代替我們真正關心的損失函數？
4.  小批量隨機梯度下降 (Minibatch SGD) 與批量梯度下降和隨機梯度下降有何不同？它在深度學習中為何受歡迎？
5.  優化問題中的「病態 (ill-conditioning)」是指什麼？它如何影響梯度下降的效率？
6.  在高維空間中，為什麼鞍點 (saddle point) 被認為比代價高的局部極小值更常見且更難處理？
7.  動量 (momentum) 方法的核心思想是什麼？它如何幫助加速訓練？
8.  Nesterov 動量與標準動量的主要區別在哪裡？這種差異帶來了什麼潛在優勢？
9.  神經網路的參數初始化為何重要？如果權重都初始化為零會發生什麼問題？
10. 批標準化 (Batch Normalization) 是什麼？它在訓練過程中起到什麼作用？

#### 申論題 (Essay Questions)

請針對以下任五題進行詳細闡述（不需提供答案）：
1.  詳細比較機器學習中的優化與純優化有何不同，並解釋為何在機器學習中我們更關心泛化性能（真實風險）而非僅僅是訓練誤差（經驗風險）的最小化。探討過擬合現象在其中的角色。
2.  深入探討神經網路優化中面臨的幾個主要挑戰：病態、局部極小值、鞍點和高原。解釋這些問題的數學含義，並說明它們對基於梯度的優化算法的影響。
3.  比較並對比批量梯度下降、隨機梯度下降和小批量隨機梯度下降。討論各自的優缺點，特別是在處理大規模數據集和利用現代硬體方面的差異，並解釋為何小批量 SGD 在深度學習中如此普遍。
4.  詳細解釋動量 (momentum) 方法和 Nesterov 動量的工作原理。分析它們如何幫助解決 Hessian 矩陣病態和隨機梯度方差大的問題。
5.  探討自適應學習率算法（如 AdaGrad, RMSProp, Adam）是如何工作的。比較它們如何獨立調整每個參數的學習率，並分析它們相較於傳統 SGD 的優勢和可能的局限性。
6.  解釋神經網路參數初始化策略的重要性。詳細介紹至少兩種常用的初始化方法（例如，Xavier/Glorot 初始化和 He 初始化），並說明它們的核心思想以及適用場景。討論不當初始化可能導致的問題。
7.  批標準化 (Batch Normalization) 是一種廣泛使用的技術，但它並非傳統意義上的優化算法。詳細解釋批標準化的工作原理、計算過程以及它如何通過緩解內部協變量偏移、加速收斂和提供正則化效果來改善深度神經網路的訓練。
8.  描述二階優化方法（如牛頓法、共軛梯度法、BFGS、L-BFGS）的基本思想。解釋它們如何利用二階導數信息，相較於一階方法有何潛在優勢，以及為什麼它們在訓練大型深度神經網路時面臨計算上的挑戰。
9.  探討「設計有助於優化的模型」這一概念。以跳躍連接/殘差連接為例，詳細解釋模型架構的改變如何能夠改善梯度流動和損失函數的景觀，從而使得訓練更深層次的網路成為可能。

---