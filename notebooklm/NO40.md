---
layout: default
title: Deep Learning 101, Taiwan’s pioneering and highest deep learning meetup, launched on 2016/11/11 @ 83F, Taipei 101
---

<p align="center">
  <strong>Deep Learning 101, Taiwan’s pioneering and highest deep learning meetup, launched on 2016/11/11 @ 83F, Taipei 101</strong>  
</p>
<p align="center">
  AI是一條孤獨且充滿惶恐及未知的旅程，花俏絢麗的收費課程或活動絕非通往成功的捷徑。<br>
  衷心感謝當時來自不同單位的AI同好參與者實名分享的寶貴經驗；如欲移除資訊還請告知。<br>
  由 <a href="https://www.twman.org/" target="_blank">TonTon Huang Ph.D.</a> 發起，及其當時任職公司(台灣雪豹科技)無償贊助場地及茶水點心。<br>
</p>  
<p align="center">
  <a href="https://huggingface.co/spaces/DeepLearning101/Deep-Learning-101-FAQ" target="_blank">
    <img src="https://github.com/Deep-Learning-101/.github/blob/main/images/DeepLearning101.JPG?raw=true" alt="Deep Learning 101" width="180"></a>
    <a href="https://www.buymeacoffee.com/DeepLearning101" target="_blank"><img src="https://cdn.buymeacoffee.com/buttons/v2/default-red.png" alt="Buy Me A Coffee" style="height: 100px !important;width: 180px !important;" ></a>
</p>
<p align="center">
  <a href="https://www.youtube.com/@DeepLearning101" target="_blank">YouTube</a> |
  <a href="https://www.facebook.com/groups/525579498272187/" target="_blank">Facebook</a> |
  <a href="https://deep-learning-101.github.io/"> 回 GitHub Pages</a> |
  <a href="http://DeepLearning101.TWMAN.ORG" target="_blank">網站</a> |
  <a href="https://huggingface.co/DeepLearning101" target="_blank">Hugging Face Space</a>
</p>


# Instance Segmentation [YouTube](https://www.youtube.com/watch?v=tXnzUd6sZz4)

### 2020/05/01	顏志翰 (Bean)

---

#### 實例分割與語義分割的區別

語義分割的目標是將圖像中的每個像素分類到預定義的語義類別之一 [2, 3, 5]。簡單來說，它只關心「這是什麼類別」[2, 4]。例如，在一張照片中，語義分割會把所有的牛都標記為「牛」這個類別，不論是哪一隻個體 [4]。換句話說，語義分割將同一類別的所有像素標記為一個整體，不區分個體 [3]。

實例分割則更進一步 [2, 4]。它不僅要識別物體的類別，還要區分屬於同一類別的不同個體，並為每個個體生成獨立的像素級掩膜（Mask）[2, 3, 6]。用牛的例子來說，實例分割不僅知道圖中有牛，還能區分出「第一隻牛」、「第二隻牛」等等，並為每一隻牛生成一個專屬的分割 Mask [4]。這點是實例分割與語義分割最主要的差異 [2]。

實例分割的主要挑戰包括物體之間的疊合、遮蔽、顏色相似以及空間上的奇異性（例如一個物體被另一個物體包圍）[2, 4]。在有物體疊合的情況下，要精確地分割出每一個獨立的個體，難度會顯著增加 [2, 7]。

#### 實例分割的主要方法：Two-stage 與 One-stage

目前實例分割的方法大致可分為兩大類：Two-stage（兩階段）方法和 One-stage（一階段）方法 [2, 4, 8]。對於新手而言，理解這兩種方法的流程是入門的第一步。

1.  **Two-stage (兩階段) 方法** [2-4]
    *   **流程：** 這類方法遵循一個「先檢測後分割」的思路 [2, 3]。首先，它會進行物體檢測（Object Detection），在圖像中找到可能包含物體的區域，這些區域被稱為物體提案（Proposal）或候選區域（Region Proposal）[2-4, 8-10]。接著，對於每一個被檢測到的物體提案，模型會再對其進行實例 Mask 的分割 [2, 4, 8]。
    *   **代表性方法：** Mask R-CNN (MCNN) 是 Two-stage 方法中最具代表性且影響力最大的模型 [2, 4, 6, 10]。它是在 Fast R-CNN 物體檢測模型的基礎上發展而來，並增加了一個用於預測每個候選區域物體 Mask 的分支 [2, 6]。
    *   **優缺點：** Two-stage 方法的優點通常是精準度較高 [2, 4]。因為它有一個明確的物體檢測階段，為後續的分割提供了良好的基礎 [2]。尤其在 COCO 排行榜上，大多數高性能方法都是基於 Mask R-CNN 進行改進的 [2]。然而，它的缺點是速度通常較慢，因為需要分兩個階段處理 [2, 4]。有資料提到，去年的 HPCK 方法在 COCO test-dev 上的 MAP 達到 43.9，但速度非常慢 [2]。研究顯示，從 2019 年到 2020 年間，Two-stage 方法的發展似乎進入瓶頸，沒有顯著突破 [11]。
    *   **關鍵點：** 核心在於「先找框（Proposal），再在框裡切 Mask」[2-4, 8]。

2.  **One-stage (一階段) 方法** [2-4]
    *   **流程：** 與 Two-stage 方法不同，One-stage 方法沒有單獨的物體提案階段 [2-4, 8]。它試圖直接從圖像中同時輸出物體的類別、位置（或相關資訊）和實例 Mask [2-4, 12]。流程更為精簡 [4]。
    *   **代表性方法：** SOLO 是一種重要的 One-stage 實例分割方法 [2, 4, 6, 11]。它直接進行分類和實例 Mask 的切割，不依賴 Region Proposal [2, 11]。
    *   **優缺點：** One-stage 方法的優點是速度通常比 Two-stage 方法快，因為處理流程更精簡 [2, 4, 13]。傳統上認為 One-stage 方法在精準度上較 Two-stage 方法差 [2, 4, 10]。然而，近期的 SOLO 等方法似乎顛覆了這種觀念 [2, 4, 10]。Solo 在 test 資料集上的 FPS 可達 31，MAP 達到 37.1，已經與 Mask R-CNN 相當甚至更高 [2]。改進後的 SOLO V2 速度更快（31.3 FPS），且 MAP 逼近最高精度方法 [2, 10]。講者認為 One-stage 方法，特別是 SOLO 這種方式，具有很大潛力 [2, 4, 10]。
    *   **關鍵點：** 核心在於「直接預測 Mask，不需要單獨找框」[2-4, 12]。

#### Bottom-up (自下而上) 方法

除了主流的 Two-stage 和 One-stage，還有 Bottom-up 方法 [2, 4, 8]。對新手來說，這種方法思路比較特別。

*   **概念與流程：** Bottom-up 方法的核心思想是先進行語義分割 [2-4, 7]。它會將同一類別的所有像素都分割出來 [2-4, 7]。然後，再將這些屬於同一語義類別的像素點投影到一個多維空間（例如 N 維的特徵空間）[2, 4, 7, 14]。最後，在這個多維空間中進行聚類（Clustering），以區分屬於同一類別的不同實例 [2-4, 7, 9]。這方法的思路是基於 CPPR 2017 的一篇論文 [2, 8, 11]。
*   **實現：** 實現上，首先進行語義分割 [2, 7]。然後訓練一個網路（例如 pre-trained 的 ResNet-38）將每個同一語義類別的像素點映射到一個 N 維的特徵空間 [2, 7]。訓練目標是讓同一實例的點在特徵空間中距離接近（拉力 Loss），不同實例的中心點距離較遠（推力 Loss）[2, 7, 9, 14]。
*   **優缺點：** Bottom-up 方法的優點是可能更能保留一些低階特徵（如顏色和位置）[2, 4, 9]。然而，其缺點也很明顯：它嚴重依賴語義分割的質量，如果語義分割做不好，後續的實例區分就很難成功 [2, 4, 9]。對於複雜場景（物體種類多）效果較差，因為一開始的語義分割可能就難以處理 [2, 4, 9]。此外，它需要後處理步驟（聚類），不是一個端到端的訓練（End-to-End）[2, 4, 9]。
*   **現狀：** 目前 Bottom-up 方法並非主流 [2, 8, 11]。但在結合 Top-down 方法（如 Two-stage）後，其混合方法在排行榜上曾達到第五名，顯示其思想仍有潛力 [2, 8]。講者認為其思路（先語義分割，再將點投影到多維空間進行分群）有趣且有潛力 [8, 11]。

#### Mask R-CNN 的核心：ROI Align

作為 Two-stage 方法的代表，Mask R-CNN 的成功很大程度上歸功於其引入的 ROI Align [2, 5, 6, 10, 11]。理解 ROI Align 對於理解 Mask R-CNN 的精度提升至關重要，也是新手需要掌握的一個重點。

*   **背景：ROI Pooling 的問題** [2, 5, 6, 15, 16]
    在 Mask R-CNN 之前，物體檢測或實例分割方法常使用 ROI Pooling 將不同大小的物體候選區域（Proposal）或感興趣區域（Region of Interest, ROI）對應到固定大小的 Feature Map 上，以便後續的分類或回歸網路處理 [2, 5, 6, 11, 16]。例如，將一個大小不一的 ROI 對應到 7x7 的 Feature Map [2, 16]。問題在於，ROI Pooling 在計算過程中使用了整數運算進行量化（Quantization）[2, 5, 15]。比如，將 ROI 的座標除以 Feature Map 的步長（stride），通常會四捨五入到最近的整數像素位置 [2, 11, 15, 16]。這種量化誤差會導致原始圖像中的位置資訊失真 [2, 5]。當我們將在 Feature Map 上預測的 Mask 反算回原始圖像時，由於這些誤差，邊界可能會不夠精確，影響實例分割的邊界準確度 [2, 3, 5, 15]。
*   **ROI Align 的解決方案** [2, 5, 6, 11, 16, 17]
    Mask R-CNN 提出了 ROI Align 來解決這個問題 [2, 5, 6, 11]。其核心思想是盡可能在整個網路管線（Pipeline）中都使用浮點數來表示位置資訊 [2, 5, 16, 17]。即使計算出的座標是浮點數，也保留浮點數 [2, 17]。在 Pooling 時，對於浮點數座標對應的像素值，ROI Align 不會簡單地取最近的整數點值 [2, 17]。而是使用雙線性插值（Bilinear Interpolation）[2, 5, 6, 17]。雙線性插值會根據周圍最近的四個像素點的像素值，按比例內插出該浮點數座標對應的精確像素值 [2, 5, 17]。這樣，得到的 Feature Map 更精確，反算回原圖時也能保持位置精確，減少邊緣誤差 [2, 17]。
*   **影響：** 儘管 Mask R-CNN 在結構上改動不大，但 ROI Align 的引入顯著提升了實例分割的精度 [2, 6, 11]。Mask R-CNN 的總損失函數包含了分類損失、邊界框回歸損失和掩碼損失 [2, 17]。有資料提到，人們可能會說 Mask R-CNN 沒做什麼「太大」的貢獻，但其效果卻極好 [2, 11, 17]。

#### SOLO 方法的機制

SOLO (Segmenting Objects by Locations) 作為 One-stage 方法的代表，其思路也值得新手學習 [2, 4, 6, 11]。

*   **核心思想：** SOLO 方法將實例分割問題視為預測像素位置與實例掩膜之間的關係 [6]。它不依賴於 Region Proposal [11]。其核心思想是將圖像切分成一個網格（Grid），例如 5x5 [2, 12]。根據物體的質心（Centroid）將其對應到某個網格單元（Grid Cell）[2, 6, 12, 18]。
*   **實現：** 模型會訓練一個分支來預測每個網格中是否存在物體質心，以及該物體所屬的類別 [12, 18]。同時，另一個分支會為每個網格生成一個對應的 Mask Channel [12, 18]。這個 Mask Channel 的數量等於網格數量的平方（S x S）[10, 12]。例如，如果是 5x5 的網格，就會有 25 個 Mask Channel [12]。如果在某個網格中檢測到物體質心，那麼與該網格對應的 Mask Channel 就會被用來生成該物體的實例 Mask [12, 18]。訓練時的目標就是讓對應於物體質心所在網格的 Mask Channel 能夠學習到該物體的精確 Mask [12]。
*   **特點：** 這是一種直接的切割方式 [2]。SOLO 也被提及會將 X 和 Y 的位置資訊加入到 Feature Map 的 Channel 中一起訓練 [10]。
*   **潛力：** Solo 方法在速度和精度上都取得了不錯的表現 [2, 4, 10]。SOLO V2 更是在速度上有了進一步加強，其精度也逼近當時的頂尖方法 [2, 4, 10, 11]。這使得 One-stage 方法顯示出很大的潛力，挑戰了傳統上 Two-stage 方法在精度上的壟斷地位 [2, 4, 10, 11]。

#### 高性能實例分割方法的改進策略：Cascading 與特徵融合

僅僅依靠單一的核心思想往往不足以達到最佳性能 [2]。目前 COCO 排行榜上的一些頂尖方法，特別是基於 Mask R-CNN 改進的方法，通常會融合多種技術策略來提升精度 [2, 6, 11, 17, 19-21]。對於希望深入研究實例分割的朋友，了解這些進階策略非常重要。

1.  **迭代式精煉 (Iterative Refinement) 或 Cascading** [2, 3, 6, 19, 20]
    *   **概念：** 將多個網路級聯（Cascade）起來，前一個網路階段的輸出作為後一個網路階段的輸入，逐步改進結果 [2, 6, 20]。這種思路可以應用於物體提案的精煉或 Mask 的改進 [2]。
    *   **應用：** 一種應用是利用前一個階段調整後的更精確的邊界框來幫助後一個階段的 Mask 預測 [2, 20]。另一種思路是利用前一個階段預測的 Mask 來幫助後一個階段的 Mask 預測，這有點類似於殘差網路（Residual Network）的概念，將前一個階段的 Mask 加入到 Feature Map 中，以幫助下一個階段做出更好的改進 [2, 6, 19-21]。這種方法通過多次迭代或串聯處理，逐步提高預測的準確度 [3, 6, 20]。

2.  **融合語義分割資訊** [1, 2, 6, 19, 21]
    *   **概念：** 將語義分割的輸出或 Feature Map 整合到實例分割的流程中 [1, 2, 6, 19, 21]。
    *   **應用：** 語義分割的輸出通常包含前景/背景資訊和類別資訊 [2, 3, 5, 21]。將這些資訊整合到實例分割的 Mask 分支中，可以幫助模型更好地理解物體的輪廓和類別歸屬，從而提升 Mask 的精準度 [2, 19, 21]。最高精度的某些方法就融合了多種 cascading 策略，並將 semantic segmentation 的 Feature Map 加入到 Mask 分支中 [2, 19, 21]。

3.  **融合其他技術** [2, 19]
    除了上述兩種，高性能方法還可能融合其他多種方法 [2, 11, 19]。例如，迭代式地改進 Bounding Box 和 Mask [11]。最高精度的 CatC 方法就被提及融合了多種方法來達到當時最高的 AP (43.2)，這可能是指 COCO 資料集上的 AP [2, 11, 17, 19]。

#### 訓練資料與評估指標

對於新手來說，了解訓練資料是什麼樣子也很重要 [18]。

*   **訓練資料：** 訓練實例分割模型需要標記好的資料集，其中包含圖像以及對應的實例 Mask 標註 [18]。對於圖像中的每個物體實例，需要標記出其所屬的類別以及精確的像素級別 Mask [18]。這意味著需要記錄每個物體的 2D 像素點，並且區分屬於同一類別的不同個體，給予不同的實例 ID [14, 18]。例如，第五類中的第一個實例標記為 5.1，第二個標記為 5.2 [14, 18]。資料集需要包含每個物體的 2D 像素點以及它們所屬的實例 ID 和類別 ID [18]。常用的資料集是 COCO 資料集 [8, 22]。
*   **評估指標：** 實例分割常用的評估指標是 AP (Average Precision) [2, 6, 11]。速度則常用 FPS (Frames Per Second) 來衡量 [2, 6]。在 COCO test-dev 資料集上獲得好的 AP 是衡量模型性能的重要標準 [8, 22].

#### 人物提及

資料中還提到了幾位人物 [23]。

*   **講者 (Speaker):** 來源影片中的主要發言人，詳細介紹了實例分割的各種方法和進展 [23]。
*   **提問者 (Questioner):** 在影片中向講者提問，問題涵蓋資料標記和網路架構 [14, 23].
*   **凱和凱明 (Kai and Kaiming):** 在影片中被提及，他們在去年（可能指 2019 或 2020 年初）提出了一種對邊界處理更好的 P 方法，據說對 Mask R-CNN 的邊界處理有幫助 [11, 21, 23].

#### 總結與展望

目前來看，Two-stage 方法在精度上仍有優勢，但速度較慢 [2, 24]。Mask R-CNN 及其改進版本在排行榜上佔據前列 [2, 11]。Mask R-CNN 的 ROI Align 解決了量化誤差問題，是精度提升的關鍵 [2, 24]。高性能方法通過級聯、迭代精煉以及融合語義分割等資訊來進一步提升精度 [2, 3, 6, 19, 21, 24]。

One-stage 方法，特別是 SOLO，在速度和精度上取得了顯著進展，具有很大的潛力，可能會顛覆傳統觀念 [2-4, 10, 24]。儘管在概念上更精簡，但實際實現也可能複雜 [13]。

Bottom-up 方法目前非主流，但其先分割再聚類的思想可能仍有潛力，尤其在與 Top-down 方法結合時 [2, 4, 8, 24]。

對於未來，講者對 3D 實例分割感興趣，希望 2D 的最新方法（如 Two-stage vs One-stage, 邊界處理, 特徵融合等）能有所啟發 [2, 6, 21, 24]。將這些概念應用於 3D 點雲或體素數據的實例分割任務，是一個值得探索的方向 [6, 24]。

這就是根據提供的資料，針對實例分割領域的一些核心概念、主要方法及其代表模型、關鍵技術以及最新進展的匯整介紹。希望這些內容能幫助剛入門的朋友們對實例分割有一個全面且深入的了解。後續可以針對感興趣的部分，進一步閱讀相關論文來深入研究 [24]。

